/**
 * Tests for the generated routes TypeScript file structure.
 *
 * These tests verify the TypeScript code that would be generated by
 * `generate_routes_ts()` on the Python side. They validate:
 * - Route function signature types
 * - Parameter type inference
 * - Helper function behavior
 */

import { describe, expect, it } from "vitest"

/**
 * Simulates a minimal generated routes file structure.
 * This mimics what `generate_routes_ts()` produces.
 */
type TestRouteName = "books" | "book_detail" | "search"

interface TestRoutePathParams {
  books: Record<string, never>
  book_detail: { book_id: number }
  search: Record<string, never>
}

interface TestRouteQueryParams {
  books: Record<string, never>
  book_detail: Record<string, never>
  search: { q: string; limit?: number }
}

type TestRouteParams<T extends TestRouteName> = TestRoutePathParams[T] & TestRouteQueryParams[T]

const testRoutes = {
  books: {
    path: "/api/books",
    methods: ["GET"] as const,
  },
  book_detail: {
    path: "/api/books/{book_id}",
    methods: ["GET"] as const,
    pathParams: ["book_id"] as const,
  },
  search: {
    path: "/api/search",
    methods: ["GET"] as const,
    queryParams: ["q", "limit"] as const,
  },
} as const

// Simulate the route function implementation
function testRoute<T extends TestRouteName>(name: T, params?: TestRouteParams<T>): string {
  const def = testRoutes[name]
  let url: string = def.path

  // Replace path parameters
  if (params && "pathParams" in def) {
    for (const param of def.pathParams) {
      const value = (params as Record<string, unknown>)[param]
      if (value !== undefined) {
        url = url.replace(`{${param}}`, String(value))
      }
    }
  }

  // Add query parameters
  if (params && "queryParams" in def) {
    const queryParts: string[] = []
    for (const param of def.queryParams) {
      const value = (params as Record<string, unknown>)[param]
      if (value !== undefined) {
        queryParts.push(`${encodeURIComponent(param)}=${encodeURIComponent(String(value))}`)
      }
    }
    if (queryParts.length > 0) {
      url += `?${queryParts.join("&")}`
    }
  }

  return url
}

function testHasRoute(name: string): name is TestRouteName {
  return name in testRoutes
}

function testGetRouteNames(): TestRouteName[] {
  return Object.keys(testRoutes) as TestRouteName[]
}

describe("Generated Routes TypeScript Structure", () => {
  describe("route() function", () => {
    it("generates URL for route without parameters", () => {
      const url = testRoute("books")
      expect(url).toBe("/api/books")
    })

    it("generates URL with path parameters", () => {
      const url = testRoute("book_detail", { book_id: 123 })
      expect(url).toBe("/api/books/123")
    })

    it("generates URL with query parameters", () => {
      const url = testRoute("search", { q: "test" })
      expect(url).toBe("/api/search?q=test")
    })

    it("generates URL with multiple query parameters", () => {
      const url = testRoute("search", { q: "test", limit: 10 })
      expect(url).toBe("/api/search?q=test&limit=10")
    })

    it("omits undefined optional query parameters", () => {
      const url = testRoute("search", { q: "test", limit: undefined })
      expect(url).toBe("/api/search?q=test")
    })

    it("encodes special characters in query parameters", () => {
      const url = testRoute("search", { q: "hello world" })
      expect(url).toBe("/api/search?q=hello%20world")
    })
  })

  describe("hasRoute() function", () => {
    it("returns true for existing routes", () => {
      expect(testHasRoute("books")).toBe(true)
      expect(testHasRoute("book_detail")).toBe(true)
      expect(testHasRoute("search")).toBe(true)
    })

    it("returns false for non-existing routes", () => {
      expect(testHasRoute("unknown")).toBe(false)
      expect(testHasRoute("")).toBe(false)
    })
  })

  describe("getRouteNames() function", () => {
    it("returns all route names", () => {
      const names = testGetRouteNames()
      expect(names).toContain("books")
      expect(names).toContain("book_detail")
      expect(names).toContain("search")
      expect(names).toHaveLength(3)
    })
  })

  describe("Type safety (compile-time)", () => {
    it("has correct type for RouteName union", () => {
      // This test ensures the type system is working
      const name: TestRouteName = "books"
      expect(name).toBe("books")
    })

    it("has correct type for path params interface", () => {
      // Type check: book_detail requires book_id parameter
      const params: TestRoutePathParams["book_detail"] = { book_id: 123 }
      expect(params.book_id).toBe(123)
    })

    it("has correct type for query params interface", () => {
      // Type check: search has q (required) and limit (optional)
      const params: TestRouteQueryParams["search"] = { q: "test" }
      expect(params.q).toBe("test")

      const paramsWithLimit: TestRouteQueryParams["search"] = { q: "test", limit: 10 }
      expect(paramsWithLimit.limit).toBe(10)
    })

    it("has correct combined params type", () => {
      // For search: only query params
      const searchParams: TestRouteParams<"search"> = { q: "test" }
      expect(searchParams.q).toBe("test")

      // For book_detail: only path params
      const detailParams: TestRouteParams<"book_detail"> = { book_id: 123 }
      expect(detailParams.book_id).toBe(123)

      // For books: empty params
      const booksParams: TestRouteParams<"books"> = {}
      expect(Object.keys(booksParams)).toHaveLength(0)
    })
  })

  describe("Routes object structure", () => {
    it("has path property for each route", () => {
      expect(testRoutes.books.path).toBe("/api/books")
      expect(testRoutes.book_detail.path).toBe("/api/books/{book_id}")
      expect(testRoutes.search.path).toBe("/api/search")
    })

    it("has methods array for each route", () => {
      expect(testRoutes.books.methods).toContain("GET")
      expect(testRoutes.book_detail.methods).toContain("GET")
    })

    it("has pathParams for routes with path parameters", () => {
      expect(testRoutes.book_detail.pathParams).toContain("book_id")
    })

    it("has queryParams for routes with query parameters", () => {
      expect(testRoutes.search.queryParams).toContain("q")
      expect(testRoutes.search.queryParams).toContain("limit")
    })
  })
})

describe("Edge cases", () => {
  it("handles empty route names list gracefully", () => {
    const emptyRoutes = {} as const
    type EmptyRouteName = keyof typeof emptyRoutes
    const names = Object.keys(emptyRoutes) as EmptyRouteName[]
    expect(names).toHaveLength(0)
  })

  it("handles routes with special characters in path", () => {
    // Apostrophes and other special chars should be escaped in generated code
    const routePath = "/api/user's-data"
    const escapedPath = routePath.replace(/'/g, "\\'")
    expect(escapedPath).toBe("/api/user\\'s-data")
  })

  it("handles numeric path parameters correctly", () => {
    const url = testRoute("book_detail", { book_id: 0 })
    expect(url).toBe("/api/books/0")
  })

  it("handles boolean-like query parameters", () => {
    // Custom route for testing
    const testUrl = (active: boolean) => {
      return `/api/filter?active=${encodeURIComponent(String(active))}`
    }
    expect(testUrl(true)).toBe("/api/filter?active=true")
    expect(testUrl(false)).toBe("/api/filter?active=false")
  })
})
