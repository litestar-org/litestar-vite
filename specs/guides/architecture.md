# Architecture Guide for litestar-vite

This document outlines the architectural patterns and conventions used in the `litestar-vite` project.

## Overview

The project follows a hybrid architecture combining a Python backend with a modern TypeScript frontend.

- **Backend**: Built with [Litestar](https://litestar.dev/), a high-performance, asynchronous ASGI framework.
- **Frontend**: Managed by [Vite](https://vitejs.dev/), a next-generation frontend build tool.
- **Integration**: The backend and frontend are connected via a manifest file generated by Vite, allowing the Litestar backend to serve the correct, hash-named JS and CSS assets. The project also includes support for [Inertia.js](https://inertiajs.com/) to build single-page applications with server-side routing.

## Backend Architecture (Python/Litestar)

The backend code is located in `src/py/litestar_vite/`.

### Key Principles

- **Asynchronous by Default**: All I/O-bound operations (database access, API calls) should be `async` to leverage Litestar's performance benefits.
- **Dependency Injection**: Litestar's dependency injection is used to manage resources like database sessions and services. Dependencies should be defined in a reusable way.
- **Configuration**: Configuration is managed through Pydantic models within the `config.py` files, allowing for type-safe and environment-aware settings.
- **Modular Design**: Core functionality is split across specialized modules (config, plugin, loader, SPA handler, Inertia integration, etc.).

### Configuration (`ViteConfig`)

The `ViteConfig` class in `config.py` controls the integration behavior. It uses a modular structure with sub-configs:

- **`PathConfig`**: File system paths (bundle_dir, resource_dir, public_dir, asset_url)
- **`RuntimeConfig`**: Execution settings (dev_mode, proxy_mode, external_dev_server, http2)
- **`TypeGenConfig`**: Type generation settings (enabled, output paths, Zod/SDK/Routes generation)
- **`InertiaConfig`**: Inertia.js settings (root_template, component_opt_keys, spa_mode)
- **`SPAConfig`**: SPA transformation settings (inject_routes, inject_csrf, cache_transformed_html)
- **`DeployConfig`**: CDN deployment settings (storage_backend, delete_orphaned, content_types)

Key `RuntimeConfig` options:

- **`dev_mode`**: Enable development mode with HMR/watch
- **`proxy_mode`**: Proxy handling mode - "vite" (whitelist), "direct" (no proxy), "proxy"/"ssr" (blacklist), or None
- **`external_dev_server`**: External dev server config (string URL or `ExternalDevServer` with custom commands)
- **`host`**, **`port`**, **`protocol`**: Vite dev server connection details
- **`executor`**: JavaScript runtime (node, bun, deno, yarn, pnpm)
- **`http2`**: Enable HTTP/2 for proxy connections (requires `h2` package)
- **`start_dev_server`**: Auto-start dev server process (default: True)
- **`is_react`**: Enable React Fast Refresh
- **`ssr_enabled`**: Enable Server-Side Rendering

Python is the source of truth: `set_environment()` now writes `.litestar.json` (path exported via `LITESTAR_VITE_CONFIG_PATH`) containing `assetUrl`, `bundleDirectory`, `resourceDirectory`, `publicDir`, `manifest`, `ssrOutDir`, typegen paths, and deploy defaults. The JS plugin consumes this file to set defaults; only override in `vite.config.ts` when you intentionally diverge.

### Core Modules

The backend is organized into specialized modules:

1. **Configuration & Plugin**:
    - `config.py`: `ViteConfig`, `SPAConfig`, and other configuration models
    - `plugin.py`: `VitePlugin` - main Litestar plugin registration

2. **Asset Management**:
    - `loader.py`: `ViteAssetLoader` - reads Vite manifest and serves assets
    - `deploy.py`: CDN deployment utilities using fsspec backends

3. **SPA Support**:
    - `spa.py`: `ViteSPAHandler` - serves SPA index.html in dev/production modes with both async and sync HTTP client support
    - `html_transform.py`: `HtmlTransformer` - HTML manipulation for route injection
    - Key features: `is_initialized` property, `get_html_sync()` for sync contexts, cached HTML in production

4. **CLI & Tooling**:
    - `cli.py`: CLI entry points for Vite integration
    - `commands.py`: CLI command implementations
    - `executor.py`: `JSExecutor` abstraction for Node/Bun/Deno runtimes
    - `doctor.py`: Diagnostic utilities for troubleshooting
    - `codegen.py`: Code generation utilities (route typegen, etc.)

5. **Scaffolding**:
    - `scaffolding/`: Project template generation and initialization

6. **Inertia.js Integration** (`inertia/`):
    - `plugin.py`: `InertiaPlugin` - Litestar plugin
    - `config.py`: `InertiaConfig` - configuration
    - `middleware.py`: `InertiaMiddleware` - handles Inertia protocol
    - `request.py`: `InertiaRequest` - enhanced request class
    - `response.py`: `InertiaResponse` - Inertia page responses
    - `routes.py`: `InertiaRoute` - specialized route handlers
    - `helpers.py`: Helper functions (`share`, `lazy`, `error`, redirects)
    - `types.py`: TypedDict and type definitions
    - `exception_handler.py`: Exception handling for Inertia requests
    - `_utils.py`: Internal utilities

## Frontend Architecture (TypeScript/Vite)

The core frontend code is located in `src/js/`. The `examples/` directory contains various frontend application examples (Vue, etc.).

### Directory Structure

```
src/js/src/
├── index.ts              # Main Vite plugin entry point
├── install-hint.ts       # Package manager detection utilities
├── litestar-meta.ts      # Runtime config loading from .litestar.json
├── globals.d.ts          # TypeScript global type definitions
├── dev-server-index.html # Dev server fallback HTML template
├── astro.ts              # Astro integration
├── nuxt.ts               # Nuxt module integration
├── sveltekit.ts          # SvelteKit integration
├── helpers/              # Frontend helper utilities
│   ├── index.ts          # Barrel export
│   ├── csrf.ts           # CSRF token utilities
│   └── routes.ts         # Route generation and matching
├── shared/               # Shared utilities across modules
│   ├── index.ts          # Barrel export
│   └── debounce.ts       # Type-safe debounce utility
└── inertia-helpers/      # Inertia.js specific helpers
    └── index.ts          # resolvePageComponent + re-exports
```

### Key Principles

- **Modularity**: Code is organized into modules and components.
- **Type Safety**: TypeScript is used throughout to ensure type safety.
- **Build Optimization**: Vite handles the development server (with HMR) and production builds. The configuration is in `vite.config.ts`.
- **DRY**: Shared utilities in `shared/` are used across framework integrations to avoid duplication.
- **Performance**: Route regex patterns are cached to avoid repeated compilation.

### Frontend Helpers (`litestar-vite-plugin/helpers`)

The helpers module provides utilities for working with Litestar routes and CSRF tokens from the frontend:

- **CSRF Utilities**: `getCsrfToken()`, `csrfHeaders()`, `csrfFetch()` - Get CSRF token from `window.__LITESTAR_CSRF__` or meta tag.
- **Route Utilities**: `route()`, `getRoutes()`, `toRoute()`, `currentRoute()`, `isRoute()`, `isCurrentRoute()` - Generate and match URLs against injected route metadata.
- **`LITESTAR` Namespace**: All helpers are also exported as a namespace object, accessible as `window.__LITESTAR__` in the browser.

Route metadata is injected by the backend via `window.__LITESTAR_ROUTES__` (SPA mode) or `window.routes` (legacy/Inertia mode).

### Type-Safe Routing (Generated)

When `types.enabled` is true (default), the Vite plugin generates a `routes.ts` file (default: `src/generated/routes.ts`) based on the exported route metadata. This provides fully typed routing:

```typescript
import { route } from '../generated/routes';

// Type-safe URL generation - checked at compile time
const url = route('users:get', { id: 123 });
```

The generated file exports:
- **`route(name, params)`**: Type-safe URL generator.
- **`routes`**: Dictionary of route metadata.
- **`RouteName`**: Union type of all available route names.
- **`RouteParams`**: Typed parameter interfaces for each route.
- **CSRF Helpers**: Re-exports `getCsrfToken`, `csrfHeaders`, `csrfFetch` for convenience.

This is the preferred routing method over the untyped runtime helpers.

### Vite Plugin Configuration

The `litestar-vite-plugin` (default export in `src/js/src/index.ts`) configures Vite to work with Litestar. Key options:

- **`input`**: Entry points to compile (required).
- **`assetUrl`**: Base path for asset URLs (default: `/static/`).
- **`bundleDirectory`**: Output directory for assets (default: `public/dist`).
- **`resourceDirectory`**: Source directory (default: `resources`).
- **`hotFile`**: Path to the hot file for HMR (default: `public/hot`).
- **`ssr`**: SSR entry point.
- **`ssrOutputDirectory`**: Output directory for SSR bundle.
- **`refresh`**: Configuration for full page reload on file changes.
- **`detectTls`**: Utilize TLS certificates.
- **`autoDetectIndex`**: Automatically detect `index.html` (default: `true`).

### Framework Integrations

The project provides integrations for multiple meta-frameworks:

#### Astro Integration (`astro.ts`)

Provides Vite integration for Astro projects with automatic HMR proxying and asset serving.

#### Nuxt Integration (`nuxt.ts`)

Nuxt 3 module that configures Vite for SSR/SPA modes with Litestar backend. Handles:

- HMR proxy setup
- SSR bundle configuration
- Build output coordination

#### SvelteKit Integration (`sveltekit.ts`)

SvelteKit adapter that bridges SvelteKit's SSR with Litestar. Features:

- Automatic adapter detection
- SSR HMR proxying
- Build artifact coordination

### Inertia.js Integration

For SPA-style applications, the project provides comprehensive Inertia.js support. The backend components are located in `src/py/litestar_vite/inertia/`, and frontend helpers are in `src/js/src/inertia-helpers/`.

#### Backend Components

- **`InertiaPlugin`**: Registers the Inertia integration with Litestar
- **`InertiaConfig`**: Configuration for Inertia integration
- **`InertiaResponse`**: Response class for rendering Inertia pages
- **`InertiaRequest`**: Enhanced request class with Inertia-specific properties
- **`InertiaMiddleware`**: Handles the Inertia protocol (headers, shared data)
- **`InertiaRoute`**: Specialized route handler for Inertia endpoints
- **Exception handling**: Automatic error page rendering for Inertia requests

#### Frontend Helpers

- **`resolvePageComponent`**: Dynamic page component resolution for code-splitting
- **Re-exports**: Provides type-safe access to Inertia adapter functions

#### Helper Functions

- **`InertiaRedirect`**, **`InertiaExternalRedirect`**: Redirect handling within Inertia
- **`InertiaBack`**: Redirect to previous page
- **`share`**: Share data across all Inertia responses
- **`lazy`**: Define lazy-loaded props for performance
- **`defer`**: Define deferred props (loaded after initial page render)
- **`merge`**: Define merge props for client-side state merging
- **`error`**: Flash error messages to client

#### Props Structure

Inertia props are flattened at the top level of the response. When your handler returns a dict, the keys are merged directly into `props`:

```python
@get("/", component="Dashboard")
def dashboard(request: Request) -> dict[str, Any]:
    return {
        "user": {"name": "Alice"},  # Becomes props.user
        "stats": {"total": 42}      # Becomes props.stats
    }
```

Non-dict content is wrapped under a `content` key:

```python
@get("/", component="UserProfile")
def profile(request: Request) -> str:
    return "Hello"  # Becomes props.content = "Hello"
```

## Communication

- **Vite Manifest**: The `ViteAssetLoader` (`loader.py`) reads the `manifest.json` file generated by `vite build`. This manifest maps source asset names to their hashed output filenames.
- **Dev Server Proxy**: During development, the Litestar application does not serve the assets directly. Instead, it proxies requests to the Vite dev server, enabling Hot Module Replacement (HMR).
- **API Calls**: For non-Inertia pages, the frontend can make standard RESTful API calls to endpoints exposed by the Litestar backend.
- **Config Synchronization**: Python writes `.litestar.json` (via `set_environment()`) that the JS plugin reads as defaults, ensuring configuration consistency.

## Example Applications

The `examples/` directory contains working examples demonstrating various integration patterns:

### Framework Examples

- **`angular/`**: Angular 18+ with signals integration
- **`angular-cli/`**: Angular CLI-based setup
- **`astro/`**: Astro static site integration
- **`nuxt/`**: Nuxt 3 SSR/SPA integration
- **`sveltekit/`**: SvelteKit SSR integration
- **`svelte/`**: Standalone Svelte 5 with runes

### React Examples

- **`react/`**: Basic React SPA
- **`react-inertia/`**: React with Inertia.js
- **`react-inertia-jinja/`**: React + Inertia with Jinja2 templates

### Vue Examples

- **`vue/`**: Basic Vue 3 SPA
- **`vue-inertia/`**: Vue 3 with Inertia.js (Composition API)
- **`vue-inertia-jinja/`**: Vue + Inertia with Jinja2 templates

### Templating & HTMX

- **`jinja-htmx/`**: HTMX hypermedia integration with Jinja2 templates


Each example includes its own `package.json`, Vite configuration, and demonstrates best practices for that particular stack.
