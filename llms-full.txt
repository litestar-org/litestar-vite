# Litestar Vite Reference

> Integration layer connecting Litestar (Python) with Vite (Node.js).
> Supports SPA, Template (Jinja), Inertia.js, and SSR workflows.

Current Version: **v0.15.0-beta.2**
Source: https://github.com/litestar-org/litestar-vite
Docs: https://litestar-org.github.io/litestar-vite/latest/

---

# 1. Architecture

**Version**: 0.15.0-beta.2 | **Updated**: 2025-12-14

This document outlines the architectural patterns and conventions used in the `litestar-vite` project.

## Overview

The project follows a hybrid architecture combining a Python backend with a modern TypeScript frontend.

- **Backend**: Built with [Litestar](https://litestar.dev/) 2.7.0+, a high-performance, asynchronous ASGI framework. Requires Python 3.10+.
- **Frontend**: Managed by [Vite](https://vitejs.dev/) 6.x or 7.x, a next-generation frontend build tool. Requires Node.js 20.19.0+ or 22.12.0+.
- **Integration**: The backend and frontend are connected via a manifest file generated by Vite, allowing the Litestar backend to serve the correct, hash-named JS and CSS assets. The project also includes comprehensive support for [Inertia.js](https://inertiajs.com/) to build single-page applications with server-side routing.

## Backend Architecture (Python/Litestar)

The backend code is located in `src/py/litestar_vite/`.

### Key Principles

- **Asynchronous by Default**: All I/O-bound operations (database access, API calls) should be `async` to leverage Litestar's performance benefits.
- **Dependency Injection**: Litestar's dependency injection is used to manage resources like database sessions and services. Dependencies should be defined in a reusable way.
- **Configuration**: Configuration is managed through Pydantic models within the `config.py` files, allowing for type-safe and environment-aware settings.
- **Modular Design**: Core functionality is split across specialized modules (config, plugin, loader, SPA handler, Inertia integration, etc.).

### Configuration (`ViteConfig`)

The `ViteConfig` class in `config.py` controls the integration behavior. It uses a modular structure with sub-configs:

- **`PathConfig`**: File system paths (root, bundle_dir, resource_dir, static_dir, asset_url, ssr_output_dir, manifest_name, hot_file)
- **`RuntimeConfig`**: Execution settings (dev_mode, proxy_mode, external_dev_server, http2, start_dev_server)
- **`TypeGenConfig`**: Type generation settings (output, openapi_path, routes_path, routes_ts_path, page_props_path, generate_zod, generate_sdk, generate_routes, generate_page_props, global_route, fallback_type, type_import_paths)
- **`InertiaConfig`**: Inertia.js settings (root_template, component_opt_keys, redirect_unauthorized_to, redirect_404, extra_static_page_props, extra_session_page_props, encrypt_history, type_gen, ssr).
- **`InertiaTypeGenConfig`**: Inertia type generation settings (include_default_auth, include_default_flash)
- **`InertiaSSRConfig`**: Inertia Server-Side Rendering settings (enabled, url, timeout)
- **`SPAConfig`**: SPA transformation settings (inject_csrf, cache_transformed_html, app_selector, csrf_var_name)
- **`LoggingConfig`**: Logging configuration (level, show_paths_absolute, suppress_npm_output, suppress_vite_banner, timestamps)
- **`DeployConfig`**: CDN deployment settings (storage_backend, delete_orphaned, content_types, include_manifest)
- **`ExternalDevServer`**: External dev server configuration (target, command, build_command, http2, enabled)
- **`PaginationContainer`**: Protocol for pagination containers (must implement `items` attribute)
- **`ViteConfig`**: Root configuration. Key fields include:
    - **`mode`**: Serving mode - "spa", "template", "htmx", "hybrid", "framework", "ssr", "ssg", or "external"
    - **`guards`**: Custom guards for the SPA catch-all route
    - **`exclude_static_from_auth`**: Exclude static file routes from authentication (default: True)
    - **`spa_path`**: Path where the SPA handler serves index.html (default: "/")
    - **`include_root_spa_paths`**: Register SPA routes at root even when spa_path is non-root (default: False)

Key `RuntimeConfig` options:

- **`dev_mode`**: Enable development mode with HMR/watch
- **`proxy_mode`**: Proxy handling mode:
    - "vite" (default): Proxy Vite assets only (allow list - SPA mode)
    - "direct": Expose Vite port directly (no proxy)
    - "proxy": Proxy everything except Litestar routes (deny list - framework mode)
    - None: No proxy (production mode)
- **`external_dev_server`**: External dev server config (string URL or `ExternalDevServer` with custom commands, http2 flag, enabled flag)
- **`host`**, **`port`**, **`protocol`**: Vite dev server connection details
- **`executor`**: JavaScript runtime (node, bun, deno, yarn, pnpm)
- **`run_command`**, **`build_command`**, **`build_watch_command`**, **`serve_command`**, **`install_command`**: Custom commands for each operation (auto-detected from executor if None)
- **`http2`**: Enable HTTP/2 for proxy HTTP connections (better multiplexing, requires `h2` package). WebSocket traffic (HMR) uses a separate connection and is unaffected. Default: True.
- **`start_dev_server`**: Auto-start dev server process (default: True). Set to False to manage the dev server manually.
- **`is_react`**: Enable React Fast Refresh
    - Framework integration is controlled by `mode="framework"` (aliases: `mode="ssr"` / `mode="ssg"`).
- **`health_check`**: Enable health check for dev server startup
- **`detect_nodeenv`**: Detect and use nodeenv in virtualenv (opt-in)
- **`set_environment`**: Set Vite environment variables from config (default: True)
- **`set_static_folders`**: Automatically configure static file serving (default: True)
- **`csp_nonce`**: Content Security Policy nonce for inline scripts
- **`spa_handler`**: Auto-register catch-all SPA route when mode="spa" (default: True)

Python is the source of truth: The VitePlugin's `on_app_init()` method writes `.litestar.json` containing `assetUrl`, `bundleDir`, `resourceDir`, `staticDir`, `manifest`, `ssrOutDir`, `mode`, `proxyMode`, `host`, `port`, `executor`, type generation paths, and Litestar version. The JS plugin reads this file automatically - only `input` is required in `vite.config.ts`. Override only when you intentionally diverge from Python config.

### Core Modules

The backend is organized into specialized modules:

1. **Configuration & Plugin**:
    - `config.py`: `ViteConfig`, `SPAConfig`, `LoggingConfig`, and other configuration models
    - `plugin.py`: `VitePlugin` - main Litestar plugin registration

2. **Asset Management**:
    - `loader.py`: `ViteAssetLoader` - reads Vite manifest and serves assets
    - `deploy.py`: CDN deployment utilities using fsspec backends

3. **SPA Support**:
    - `handler.py` (exposes `AppHandler`): Serves SPA index.html in dev/production modes with both async and sync HTTP client support.
    - `html_transform.py`: HTML transformation functions (`inject_head_script`, `inject_body_content`, `inject_json_script`, `set_data_attribute`)
    - Key features: `is_initialized` property, `get_html(request)` for async contexts, `get_html_sync()` for sync contexts, cached HTML in production with `SPAConfig.cache_transformed_html`

4. **CLI & Tooling**:
    - `cli.py`: CLI entry points for Vite integration
    - `commands.py`: CLI command implementations
    - `executor.py`: `JSExecutor` abstraction for Node/Bun/Deno runtimes
    - `doctor.py`: Diagnostic utilities for troubleshooting
    - `codegen.py`: Code generation utilities (route typegen, etc.)

5. **Scaffolding**:
    - `scaffolding/`: Project template generation and initialization

6. **Inertia.js Integration** (`inertia/`):
    - `plugin.py`: `InertiaPlugin` - Litestar plugin with BlockingPortal for async DeferredProp resolution
    - `config.py`: `InertiaConfig` - configuration (moved to main config.py in v0.15)
    - `middleware.py`: `InertiaMiddleware` - handles Inertia protocol
    - `request.py`: `InertiaRequest` - enhanced request class with InertiaDetails/InertiaHeaders
    - `response.py`: `InertiaResponse` - Inertia page responses with props flattening
    - `routes.py`: `generate_js_routes` - route metadata generation for TypeScript
    - `helpers.py`: Helper functions (`share`, `lazy`, `defer`, `merge`, `error`, `flash`, `only`, `except_`, `clear_history`, `scroll_props`, `get_shared_props`, `extract_deferred_props`, `extract_merge_props`)
    - `exception_handler.py`: Exception handling for Inertia requests (`exception_to_http_response`, `create_inertia_exception_response`)
    - `_utils.py`: Internal utilities

## Frontend Architecture (TypeScript/Vite)

The core frontend code is located in `src/js/`. The `examples/` directory contains various frontend application examples (Vue, etc.).

### Directory Structure

```
src/js/src/
├── index.ts              # Main Vite plugin entry point
├── install-hint.ts       # Package manager detection utilities
├── litestar-meta.ts      # Runtime config loading from .litestar.json
├── dev-server-index.html # Dev server fallback HTML template
├── astro.ts              # Astro integration
├── nuxt.ts               # Nuxt module integration
├── sveltekit.ts          # SvelteKit integration
├── helpers/              # Frontend helper utilities
│   ├── index.ts          # Barrel export
│   ├── csrf.ts           # CSRF token utilities (getCsrfToken, csrfHeaders, csrfFetch)
│   ├── htmx.ts           # HTMX utilities (addDirective, registerHtmxExtension, setHtmxDebug, swapJson)
│   └── routes.ts         # Runtime route helpers (legacy)
├── shared/               # Shared utilities across modules
│   ├── bridge-schema.ts  # Bridge file type definitions
│   ├── debounce.ts       # Type-safe debounce utility
│   ├── logger.ts         # Logging utility
│   └── typegen-plugin.ts # Type generation plugin
└── inertia-helpers/      # Inertia.js specific helpers
    └── index.ts          # resolvePageComponent + re-exports
```

### Key Principles

- **Modularity**: Code is organized into modules and components.
- **Type Safety**: TypeScript is used throughout to ensure type safety.
- **Build Optimization**: Vite handles the development server (with HMR) and production builds. The configuration is in `vite.config.ts`.
- **DRY**: Shared utilities in `shared/` are used across framework integrations to avoid duplication.
- **Performance**: Route regex patterns are cached to avoid repeated compilation.

### Frontend Helpers (`litestar-vite-plugin/helpers`)

The helpers module provides utilities for working with Litestar routes and CSRF tokens from the frontend:

- **CSRF Utilities**: `getCsrfToken()`, `csrfHeaders()`, `csrfFetch()` - Get CSRF token from `window.__LITESTAR_CSRF__` or meta tag.
- **HTMX Utilities** (NEW in v0.15):
    - `addDirective(name, handler)` - Register custom HTMX directives
    - `registerHtmxExtension(name, extension)` - Register HTMX extensions
    - `setHtmxDebug(enabled)` - Enable/disable HTMX debug mode
    - `swapJson(target, json)` - Swap element content with JSON data

Route metadata is now generated as TypeScript at build time (see Type-Safe Routing below). Runtime route helpers are deprecated in favor of the generated routes.ts file.

### Type-Safe Routing (Generated)

When `types=TypeGenConfig(generate_routes=True)` is enabled (default), the Python backend generates route metadata that the Vite plugin uses to create a `routes.ts` file (default: `src/generated/routes.ts`). This provides fully typed routing:

```typescript
import { route } from '../generated/routes';

// Type-safe URL generation - checked at compile time
const url = route('users:get', { id: 123 });
```

The generated file exports:

- **`route(name, params)`**: Type-safe URL generator.
- **`routes`**: Dictionary of route metadata.
- **`RouteName`**: Union type of all available route names.
- **`RouteParams`**: Typed parameter interfaces for each route.
- **Semantic aliases**: When OpenAPI includes `format` (e.g. `uuid`, `date-time`), generated TS includes lightweight aliases (e.g. `type UUID = string`) and uses them in param types.
- **CSRF Helpers**: Re-exports `getCsrfToken`, `csrfHeaders`, `csrfFetch` for convenience.

This is the preferred routing method over the untyped runtime helpers.

Configuration:

- **Python**: `ViteConfig(types=TypeGenConfig(generate_routes=True, routes_ts_path=Path("src/generated/routes.ts")))`
- **Vite Plugin**: Reads `routes.json` metadata and generates TypeScript at build time

### Vite Plugin Configuration

The `litestar-vite-plugin` (default export in `src/js/src/index.ts`) configures Vite to work with Litestar.

When running via Litestar CLI, the plugin reads defaults from `.litestar.json` automatically. Only `input` is required:

```typescript
litestar({ input: ['src/main.ts'] })
```

Key options (auto-populated from `.litestar.json` when available):

- **`input`**: Entry points to compile (**required**).
- **`assetUrl`**: Base path for asset URLs (default: `/static/`).
- **`bundleDir`**: Output directory for assets (default: `public`).
- **`resourceDir`**: Source directory (default: `resources`).
- **`hotFile`**: Path to the hot file for HMR (default: `${bundleDir}/hot`).
- **`ssr`**: SSR entry point.
- **`ssrOutDir`**: Output directory for SSR bundle.
- **`refresh`**: Configuration for full page reload on file changes.
- **`detectTls`**: Utilize TLS certificates.
- **`autoDetectIndex`**: Automatically detect `index.html` (default: `true`).
- **`inertiaMode`**: Disable index auto-detection for Inertia apps (auto-detected from `.litestar.json`).
- **`transformOnServe`**: Apply HTML transformations in dev mode (default: `true`).
- **`types`**: Type generation configuration.
- **`executor`**: JavaScript runtime executor.

### Framework Integrations

The project provides integrations for multiple meta-frameworks:

#### Astro Integration (`astro.ts`)

Provides Vite integration for Astro projects with automatic HMR proxying and asset serving.

#### Nuxt Integration (`nuxt.ts`)

Nuxt 3 module that configures Vite for SSR/SPA modes with Litestar backend. Handles:

- HMR proxy setup
- SSR bundle configuration
- Build output coordination

#### SvelteKit Integration (`sveltekit.ts`)

SvelteKit adapter that bridges SvelteKit's SSR with Litestar. Features:

- Automatic adapter detection
- SSR HMR proxying
- Build artifact coordination

### Inertia.js Integration

For SPA-style applications, the project provides comprehensive Inertia.js support. The backend components are located in `src/py/litestar_vite/inertia/`, and frontend helpers are in `src/js/src/inertia-helpers/`.

#### Backend Components

- **`InertiaPlugin`**: Registers the Inertia integration with Litestar. Includes BlockingPortal lifespan for async DeferredProp resolution in type encoders.
- **`InertiaConfig`**: Configuration for Inertia integration
- **`InertiaResponse`**: Response class for rendering Inertia pages with automatic props flattening
- **`InertiaRequest`**: Enhanced request class with Inertia-specific properties (InertiaDetails, InertiaHeaders)
- **`InertiaMiddleware`**: Handles the Inertia protocol (headers, shared data)
- **Route handlers**: Use `component="ComponentName"` in route options (or `page=` as alias)
- **Exception handling**: Automatic error page rendering for Inertia requests via exception handlers

#### Frontend Helpers

- **`resolvePageComponent`**: Dynamic page component resolution for code-splitting
- **`unwrapPageProps`**: Utility to unwrap Litestar's `content` prop from Inertia page props
- **Re-exports**: Provides type-safe access to Inertia adapter functions

#### Helper Functions

- **`InertiaRedirect`**, **`InertiaExternalRedirect`**: Redirect handling within Inertia
- **`InertiaBack`**: Redirect to previous page
- **`share`**: Share data across all Inertia responses
- **`lazy`**: Define lazy-loaded props for performance (excluded from initial page load, sent on partial reloads)
- **`defer`**: Define deferred props (loaded after initial page render, Inertia v2 feature)
- **`merge`**: Define merge props for client-side state merging (Inertia v2 feature)
- **`error`**: Flash error messages to client
- **`flash`**: Flash messages to the next request
- **`only`**: Filter props to only include specified keys (PropFilter)
- **`except_`**: Filter props to exclude specified keys (PropFilter)
- **`clear_history`**: Clear browser history on next response (Inertia v2 feature)
- **`scroll_props`**: Generate pagination metadata for scroll regions (supports PaginationContainer protocol)
- **`get_shared_props`**: Retrieve shared props from request state
- **`extract_deferred_props`**: Extract deferred props from a dict
- **`extract_merge_props`**: Extract merge props from a dict
- **`create_inertia_exception_response`**: Create Inertia error responses
- **`exception_to_http_response`**: Convert exceptions to HTTP responses

#### Props Structure

Inertia props are flattened at the top level of the response. When your handler returns a dict, the keys are merged directly into `props`:

```python
@get("/", component="Dashboard")
def dashboard(request: Request) -> dict[str, Any]:
    return {
        "user": {"name": "Alice"},  # Becomes props.user
        "stats": {"total": 42}      # Becomes props.stats
    }
```

Non-dict content is wrapped under a `content` key:

```python
@get("/", component="UserProfile")
def profile(request: Request) -> str:
    return "Hello"  # Becomes props.content = "Hello"
```

Pagination unwrapping: If a handler returns a `PaginationContainer` (implements protocol with `items` attribute), InertiaResponse automatically unwraps it for Inertia scroll regions:

```python
@get("/users", component="UserList")
def user_list(request: Request) -> OffsetPagination[User]:
    return pagination_result  # Auto-unwrapped: props.items + scroll metadata
```

## Communication

- **Vite Manifest**: The `ViteAssetLoader` (`loader.py`) reads the `manifest.json` file generated by `vite build`. This manifest maps source asset names to their hashed output filenames.
- **Dev Server Proxy**: During development, the Litestar application does not serve the assets directly. Instead, it proxies requests to the Vite dev server, enabling Hot Module Replacement (HMR).
- **API Calls**: For non-Inertia pages, the frontend can make standard RESTful API calls to endpoints exposed by the Litestar backend.
- **Config Synchronization**: Python writes `.litestar.json` (via `set_environment()`) that the JS plugin reads as defaults, ensuring configuration consistency.

## Example Applications

The `examples/` directory contains working examples demonstrating various integration patterns:

### Framework Examples

- **`angular/`**: Angular 18+ with signals integration
- **`angular-cli/`**: Angular CLI-based setup
- **`astro/`**: Astro static site integration
- **`nuxt/`**: Nuxt 3 SSR/SPA integration
- **`sveltekit/`**: SvelteKit SSR integration
- **`svelte/`**: Standalone Svelte 5 with runes

### React Examples

- **`react/`**: Basic React SPA
- **`react-inertia/`**: React with Inertia.js
- **`react-inertia-jinja/`**: React + Inertia with Jinja2 templates

### Vue Examples

- **`vue/`**: Basic Vue 3 SPA
- **`vue-inertia/`**: Vue 3 with Inertia.js (Composition API)
- **`vue-inertia-jinja/`**: Vue + Inertia with Jinja2 templates

### Templating & HTMX

- **`jinja-htmx/`**: HTMX hypermedia integration with Jinja2 templates

Each example includes its own `package.json`, Vite configuration, and demonstrates best practices for that particular stack.

---

# 2. Code Style

**Version**: 0.15.0-beta.2 | **Updated**: 2025-12-14

This document defines the code style and quality standards for both the Python backend and TypeScript frontend. Consistency is enforced through automated tooling.

## General Principles

- **Clarity**: Write code that is easy to read and understand.
- **Explicitness**: Prefer explicit over implicit.
- **Consistency**: Adhere to the existing code style in the project.

## Python Code Style

All Python code is automatically formatted and linted using tools configured in `pyproject.toml` and run via `pre-commit` hooks.

- **Formatter**: [Ruff](https://docs.astral.sh/ruff/) is used for formatting, effectively replacing Black and isort.
- **Linter**: [Ruff](https://docs.astral.sh/ruff/) is also used for linting, providing fast and comprehensive checks.
- **Type Checking**: [MyPy](http://mypy-lang.org/) is used for static type checking.

### Key Standards

1. **Type Hinting**:
    - All functions and methods must have type hints for arguments and return values.
    - Use modern type hints (PEP 604): `list[str]` instead of `List[str]`, and `str | None` instead of `Optional[str]`.
    - Do **not** use `from __future__ import annotations`.

2. **Docstrings**:
    - All public modules, classes, functions, and methods must have a docstring.
    - Follow the [Google Python Style Guide](https://google.github.io/styleguide/pyguide.html#3.8-comments-and-docstrings) for docstrings.

3. **Imports**:
    - Imports are automatically sorted by Ruff.
    - Group imports logically (standard library, third-party, first-party).

### Additional Python Tools

- **Slotscheck**: Validates `__slots__` definitions for memory efficiency
- **Pre-commit**: Automated hooks for code quality (configured in `.pre-commit-config.yaml`)

### Tooling Commands

- **Lint & Type-Check**: `make lint` (runs pre-commit, mypy, pyright, slotscheck)
- **Auto-format**: `make fix` (runs ruff with auto-fixes)
- **Type-check only**: `make type-check` (runs mypy + pyright)
- **Slotscheck**: `make slotscheck` (validates `__slots__`)
- **Individual type checkers**:
    - `make mypy` - MyPy with cache
    - `make pyright` - Pyright
    - `make basedpyright` - Stricter Pyright variant

### Config Source of Truth

- When both Python and Vite need the same values (asset/base URL, bundle/resource dirs, manifest), prefer setting them in `ViteConfig`. The plugin's `on_app_init()` method writes `.litestar.json` during startup and the JS plugin uses it as defaults. Keep `vite.config.ts` overrides minimal.
- See `specs/guides/config-precedence.md` for detailed configuration flow documentation.

## TypeScript/JavaScript Code Style

The frontend codebase (primarily in `src/js/` and `examples/`) is managed by [Biome](https://biomejs.dev/).

- **Formatter**: Biome handles all code formatting.
- **Linter**: Biome provides comprehensive linting rules.

Configuration is defined in `biome.json`.

### Key Standards

1. **Formatting**:
    - Follow the settings in `biome.json` (e.g., indentation, line width).
    - Do not manually format code; let the tooling handle it.

2. **Language Features**:
    - Prefer modern ECMAScript features (e.g., `const`/`let` over `var`, arrow functions).
    - Use TypeScript for all new code to ensure type safety.

### Tooling Commands

The pre-commit hooks automatically run Biome. To run it manually:

```bash
# Format and lint all relevant files
npx biome check --write .
```

## Pre-Commit Hooks

This project uses `pre-commit` to ensure that all code committed to the repository meets our quality standards. The hooks are defined in `.pre-commit-config.yaml` and are installed automatically when you run `make install`.

The hooks will automatically run `ruff`, `biome`, `mypy`, and other checks before allowing a commit to be created.

---

# 3. Configuration Precedence

**Version**: 0.15.0-beta.2 | **Updated**: 2025-12-14

```
┌─────────────────────┐
│   Python ViteConfig │
│   (VitePlugin)      │
└─────────┬───────────┘
          │ on_app_init()
          ▼
┌─────────────────────┐
│   .litestar.json    │
│   (Bridge File)     │
└─────────┬───────────┘
          │ loadPythonDefaults()
          ▼
┌─────────────────────┐    ┌─────────────────────┐
│   vite.config.ts    │───▶│  Resolved Config    │
│   (User TS Config)  │    │  + Validation       │
└─────────────────────┘    └─────────────────────┘
```

## Precedence Chain

**`vite.config.ts` > `.litestar.json` > hardcoded defaults**

1. **vite.config.ts** - Explicit user configuration takes highest priority
2. **.litestar.json** - Python-generated bridge file provides defaults
3. **Hardcoded defaults** - Built-in fallbacks when neither is available

## The Bridge File (`.litestar.json`)

When Litestar starts, it writes a `.litestar.json` file containing shared configuration.

## Field Classification

### Shared Fields (in `.litestar.json`)

These fields are meaningful to both Python and TypeScript:

| Field | Python Name | JSON/TypeScript Name | Description |
|-------|-------------|---------------------|-------------|
| Asset URL | `asset_url` | `assetUrl` | Base URL for assets |
| Bundle Directory | `bundle_dir` | `bundleDir` | Build output directory |
| Resource Directory | `resource_dir` | `resourceDir` | Source assets directory |
| Static Directory | `static_dir` | `staticDir` | Static assets directory |
| Hot File | `hot_file` | `hotFile` | Dev server URL file |
| Manifest Name | `manifest_name` | `manifest` | Build manifest filename |
| Mode | `mode` | `mode` | Operation mode |
| Proxy Mode | `proxy_mode` | `proxyMode` | Dev proxy configuration |
| Host | `host` | `host` | Dev server host |
| Port | `port` | `port` | Dev server port |
| SSR Output Dir | `ssr_output_dir` | `ssrOutDir` | SSR build output |
| Executor | `runtime.executor` | `executor` | Package manager command |
| Logging | `logging` | `logging` | Logging configuration |

### Python-Only Fields

These are configured in Python and not exposed to TypeScript:

- `DeployConfig` - CDN deployment settings (storage_backend, delete_orphaned, include_manifest, content_types)
- `SPAConfig` - Single-page app settings (inject_csrf, cache_transformed_html, csrf_var_name, app_selector)
- `InertiaConfig` - Inertia.js integration settings (root_template, component_opt_keys, encrypt_history, type_gen)
- `InertiaTypeGenConfig` - Inertia type generation (include_default_auth, include_default_flash)
- `InertiaSSRConfig` - Inertia SSR settings (enabled, url, timeout)
- `RuntimeConfig.run_command`, `build_command`, `serve_command`, `install_command`, etc.
- `RuntimeConfig.http2`, `start_dev_server`, `health_check`, `detect_nodeenv`, `set_environment`, `set_static_folders`, `csp_nonce`, `spa_handler`
- `ExternalDevServer` - External dev server config (target, command, build_command, http2, enabled)
- `PaginationContainer` - Protocol for pagination unwrapping
- `ViteConfig` fields: `guards`, `exclude_static_from_auth`, `spa_path`, `include_root_spa_paths`

### TypeScript-Only Fields

These are configured in `vite.config.ts` only:

- `input` - Entry point files
- `refresh` - HMR file patterns
- `detectTls` - Auto-detect HTTPS
- `autoDetectIndex` - Find index.html
- `transformOnServe` - HTML transforms in dev
- `types.debounce` - File watch debounce
- Vite-specific plugins, aliases, etc.

## Naming Convention

- **JSON/TypeScript**: `camelCase` (JavaScript convention)
- **Python**: `snake_case` (Python convention)

The bridge file uses camelCase since it's primarily consumed by JavaScript.

## Configuration Validation

The TypeScript plugin validates configuration against Python defaults and warns on mismatches:

```
[litestar-vite] Configuration mismatch detected:
  • bundleDir: vite.config.ts="dist" differs from Python="public"

Precedence: vite.config.ts > .litestar.json > defaults
See: https://docs.litestar.dev/vite/config-precedence
```

This helps catch configuration drift between Python and TypeScript.

## Best Practices

1. **Let Python Drive Shared Config**: Configure shared settings in Python's `ViteConfig`.
2. **Keep vite.config.ts Minimal**: Only specify TypeScript-specific options.
3. **Override Only When Necessary**: If you need to override Python defaults in TypeScript, expect a warning.

---

# 4. Development Workflow

**Version**: 0.15.0-beta.2 | **Updated**: 2025-12-14

## 1. Initial Setup

All project tasks are managed through a `Makefile` and the `uv` Python package manager.

1. **Prerequisites**: Python 3.10+, Node.js 20.19.0+ or 22.12.0+, `curl`.
2. **Install `uv`**: `curl -LsSf https://astral.sh/uv/install.sh | sh`
3. **Install Project Dependencies**: `make install`

## 2. Daily Development

### Frontend directory conventions

- Inertia variants use `resources/`.
- Other templates use `src/`.
- Relocate frontend via `litestar assets init --frontend-dir web`.

### Running the Development Server

- **Run Litestar App (starts/proxies Vite)**:
    ```bash
    uv run litestar --app examples.vue.app:app run --reload
    ```
- **Two-port option (start Vite yourself)**:
    ```bash
    uv run litestar --app examples.vue.app:app assets serve
    uv run litestar --app examples.vue.app:app run --reload
    ```

### Running Tests

```bash
# Run the full test suite (Python and JS)
make test

# Run only Python tests
pytest src/py/tests/

# Run only JS tests
npm run test --workspace=src/js
```

### Code Quality

```bash
# Run all linters and type checkers
make lint

# Auto-format your code
make fix
```

## 3. Committing and Pre-Commit Hooks

This project uses `pre-commit` to enforce code quality at the time of commit.

## 4. Release Workflow

### Standard Release

```bash
make release bump=patch   # or minor/major
git push origin main
gh release create v0.15.0 --title "v0.15.0" --generate-notes
```

### Pre-releases (Alpha/Beta/RC)

```bash
make pre-release version=0.15.0-beta.1
git push origin HEAD
gh release create v0.15.0-beta.1 --prerelease --title "v0.15.0-beta.1"
```

---

# 5. Testing Guide

**Version**: 0.15.0-beta.2 | **Updated**: 2025-12-14

## Overview

- **Backend (Python)**: [pytest](https://docs.pytest.org/).
- **Frontend (TypeScript)**: [Vitest](https://vitest.dev/).

The full test suite can be run with a single command: `make test`.

## Backend Testing (pytest)

- **Function-Based Tests**: All tests **must** be function-based. Do not use class-based tests.
- **Fixtures**: Use `pytest` fixtures (`@pytest.fixture`).
- **Async Tests**: Mark `async` test functions with `@pytest.mark.asyncio`.
- **Coverage**: Aim for at least 90% test coverage (`make coverage`).

### Recent Test Patterns

1. **Props flattening tests**: Verify dict props are merged at top-level
2. **Content wrapping tests**: Verify non-dict content goes under `content` key
3. **Inertia protocol tests**: Test v2 protocol features (deferred, merge, prepend props)

## Frontend Testing (Vitest)

- **Modern Syntax**: Use modern ES module syntax.
- **Mocking**: Use Vitest's built-in mocking capabilities.

## Full Suite

```bash
# Run all tests (Python + JS)
make test

# Run all linting, type-checking, and tests
make check-all

# Run with coverage report
make coverage
```

## Type Checking

```bash
# Run all type checkers
make type-check
```

## End-to-End (E2E) Testing

### Critical: Use Litestar CLI Commands

**ALWAYS use `litestar assets` commands instead of npm/node directly in tests!**

```python
# CORRECT - Uses Litestar CLI
def start_dev_mode():
    subprocess.Popen(["litestar", "assets", "serve"], cwd=example_dir, env=env)
    subprocess.Popen(["litestar", "run", "--port", str(port)], cwd=example_dir, env=env)
```

**Why this matters:**
- The Litestar CLI manages port allocation, environment variables, and process coordination
- Direct npm commands bypass the Python-JS integration layer

---

# 6. Quality Gates

**Version**: 0.15.0-beta.2 | **Updated**: 2025-12-14

## Implementation Gates
- `make test`: All tests must pass.
- `make lint`: Zero linting errors allowed.
- `make type-check`: Type checking must pass.

## Testing Gates
- **Coverage**: 90%+ for modified modules.
- **All Tests**: Must pass.
- **Parallel**: Tests must work in parallel (`pytest -n auto`).
- **N+1**: Database operations must include N+1 query detection.
- **Concurrent**: Shared state must include concurrent access tests.

## Documentation Gates
- **Anti-Patterns**:
  - No `from __future__ import annotations`
  - No `Optional[...]` (use `T | None`)
  - No `class Test` (use function-based tests)
  - Limit `hasattr`/`getattr`

- **Recent Patterns Documented**:
  - Props flattening in InertiaResponse
  - ViteSPAHandler.is_initialized
  - HTTP/2 support
  - ExternalDevServer
  - InertiaTypeGenConfig
  - HTMX helper utilities
  - Inertia v2 features (defer, clear_history, encrypt_history)
  - PaginationContainer

---

# 7. Python API Reference

### `ViteConfig`
Root configuration object passed to `VitePlugin`.

```python
from litestar_vite import ViteConfig, RuntimeConfig, PathConfig, LoggingConfig

config = ViteConfig(
    mode="spa",           # "spa", "template", "htmx", "hybrid", "framework", "ssr", "external"
    dev_mode=True,        # Enable HMR/Watch (default: check env VITE_DEV_MODE)
    base_url="/static/",  # CDN/Asset URL (default: env VITE_BASE_URL)
    paths=PathConfig(
        root=".",
        bundle_dir="public",
        resource_dir="src",
        static_dir="public",
        manifest_name="manifest.json",
        hot_file="hot",
        asset_url="/static/",
        ssr_output_dir=None
    ),
    runtime=RuntimeConfig(
        port=5173,
        host="127.0.0.1",
        protocol="http",
        executor="node",       # "node", "bun", "deno", "yarn", "pnpm"
        proxy_mode="vite",     # "vite" (allowlist), "proxy" (blocklist), "direct", None
        external_dev_server=None,  # ExternalDevServer config
        is_react=False,
        health_check=False,
        detect_nodeenv=False,
        set_environment=True,
        set_static_folders=True,
        csp_nonce=None,
        spa_handler=True,
        http2=True,
        start_dev_server=True
    ),
    # Feature flags
    types=True,           # Enable type generation (TypeGenConfig)
    inertia=True,         # Enable Inertia.js (InertiaConfig)
    spa=True,             # Enable SPA transformations (SPAConfig)
    deploy=False,         # Enable CDN deployment (DeployConfig)
    logging=LoggingConfig(level="normal"), # Logging settings

    # Advanced
    guards=None,          # Guards for SPA catch-all route
    exclude_static_from_auth=True, # Exclude static assets from auth middleware
    spa_path=None,        # Path to serve SPA (default: "/")
    include_root_spa_paths=False # Also serve at "/" if spa_path is non-root
)
```

### `InertiaConfig`
Configuration for InertiaJS support.

```python
from litestar_vite import InertiaConfig, InertiaSSRConfig, InertiaTypeGenConfig

config = InertiaConfig(
    root_template="index.html",
    component_opt_keys=("component", "page"),
    redirect_unauthorized_to=None,
    redirect_404=None,
    extra_static_page_props={},
    extra_session_page_props=set(),
    encrypt_history=False,  # Enable v2 browser history encryption (Requires Inertia v2)
    type_gen=InertiaTypeGenConfig(
        include_default_auth=True,
        include_default_flash=True
    ),
    ssr=InertiaSSRConfig(   # Enable Inertia SSR
        enabled=True,
        url="http://127.0.0.1:13714/render",
        timeout=2.0
    ) # Requires running external Node SSR server
)
```

### `Inertia Helpers`
Helpers for Inertia.js integration.

```python
from litestar_vite.inertia import (
    share, lazy, defer, merge, flash, error,
    only, except_, clear_history, scroll_props,
    get_shared_props, extract_deferred_props, extract_merge_props
)

# Share props globally
share(request, "user", current_user)

# Lazy props (v1 style)
lazy("permissions", lambda: Permission.all())

# Deferred props (Requires Inertia v2)
defer("notifications", fetch_notifications, group="sidebar")

# Merge props
merge("filters", current_filters)

# Flash messages
flash(request, "success", "Item saved!")

# Validation errors
error(request, "email", "Email is required")

# History encryption (Requires Inertia v2)
clear_history()  # Clear encrypted history on next response

# Infinite scroll props (Requires Inertia v2)
scroll_props(items, total=100, limit=20, offset=0)
```

### `Inertia Response Classes`

```python
from litestar_vite.inertia import (
    InertiaResponse, InertiaRedirect, InertiaBack, InertiaExternalRedirect
)

@get("/dashboard", component="Dashboard")
async def dashboard() -> InertiaResponse:
    return InertiaResponse(
        {"stats": get_stats()},
        encrypt_history=True,  # Override global setting (Requires Inertia v2)
        clear_history=False
    )
```
