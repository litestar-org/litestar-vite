# Litestar Vite: Comprehensive Documentation

**Version**: 0.15.0-beta.2
**Project**: litestar-vite

Seamless integration between Litestar and Vite with Inertia.js support.
This document contains the full context of the project, including architecture, guides, and API reference.

---

# 1. Architecture Guide

**Version**: 0.15.0-beta.2 | **Updated**: 2025-12-14

This document outlines the architectural patterns and conventions used in the `litestar-vite` project.

## Overview

The project follows a hybrid architecture combining a Python backend with a modern TypeScript frontend.

- **Backend**: Built with [Litestar](https://litestar.dev/) 2.7.0+, a high-performance, asynchronous ASGI framework. Requires Python 3.10+.
- **Frontend**: Managed by [Vite](https://vitejs.dev/) 6.x or 7.x, a next-generation frontend build tool. Requires Node.js 20.19.0+ or 22.12.0+.
- **Integration**: The backend and frontend are connected via a manifest file generated by Vite, allowing the Litestar backend to serve the correct, hash-named JS and CSS assets. The project also includes comprehensive support for [Inertia.js](https://inertiajs.com/) to build single-page applications with server-side routing.

## Backend Architecture (Python/Litestar)

The backend code is located in `src/py/litestar_vite/`.

### Key Principles

- **Asynchronous by Default**: All I/O-bound operations (database access, API calls) should be `async` to leverage Litestar's performance benefits.
- **Dependency Injection**: Litestar's dependency injection is used to manage resources like database sessions and services. Dependencies should be defined in a reusable way.
- **Configuration**: Configuration is managed through Pydantic models within the `config.py` files, allowing for type-safe and environment-aware settings.
- **Modular Design**: Core functionality is split across specialized modules (config, plugin, loader, SPA handler, Inertia integration, etc.).

### Configuration (`ViteConfig`)

The `ViteConfig` class in `config.py` controls the integration behavior. It uses a modular structure with sub-configs:

- **`PathConfig`**: File system paths (root, bundle_dir, resource_dir, static_dir, asset_url, ssr_output_dir, manifest_name, hot_file)
- **`RuntimeConfig`**: Execution settings (dev_mode, proxy_mode, external_dev_server, http2, start_dev_server)
- **`TypeGenConfig`**: Type generation settings (output, openapi_path, routes_path, routes_ts_path, page_props_path, generate_zod, generate_sdk, generate_routes, generate_page_props, global_route, fallback_type, type_import_paths)
- **`InertiaConfig`**: Inertia.js settings (root_template, component_opt_keys, redirect_unauthorized_to, redirect_404, extra_static_page_props, extra_session_page_props, encrypt_history, type_gen, ssr).
- **`InertiaTypeGenConfig`**: Inertia type generation settings (include_default_auth, include_default_flash)
- **`InertiaSSRConfig`**: Inertia Server-Side Rendering settings (enabled, url, timeout)
- **`SPAConfig`**: SPA transformation settings (inject_csrf, cache_transformed_html, app_selector, csrf_var_name)
- **`LoggingConfig`**: Logging configuration (level, show_paths_absolute, suppress_npm_output, suppress_vite_banner, timestamps)
- **`DeployConfig`**: CDN deployment settings (storage_backend, delete_orphaned, content_types, include_manifest)
- **`ExternalDevServer`**: External dev server configuration (target, command, build_command, http2, enabled)
- **`PaginationContainer`**: Protocol for pagination containers (must implement `items` attribute)
- **`ViteConfig`**: Root configuration. Key fields include:
    - **`mode`**: Serving mode - "spa", "template", "htmx", "hybrid", "framework", "ssr", "ssg", or "external"
    - **`guards`**: Custom guards for the SPA catch-all route
    - **`exclude_static_from_auth`**: Exclude static file routes from authentication (default: True)
    - **`spa_path`**: Path where the SPA handler serves index.html (default: "/")
    - **`include_root_spa_paths`**: Register SPA routes at root even when spa_path is non-root (default: False)

Key `RuntimeConfig` options:

- **`dev_mode`**: Enable development mode with HMR/watch
- **`proxy_mode`**: Proxy handling mode:
    - "vite" (default): Proxy Vite assets only (allow list - SPA mode)
    - "direct": Expose Vite port directly (no proxy)
    - "proxy": Proxy everything except Litestar routes (deny list - framework mode)
    - None: No proxy (production mode)
- **`external_dev_server`**: External dev server config (string URL or `ExternalDevServer` with custom commands, http2 flag, enabled flag)
- **`host`**, **`port`**, **`protocol`**: Vite dev server connection details
- **`executor`**: JavaScript runtime (node, bun, deno, yarn, pnpm)
- **`run_command`**, **`build_command`**, **`build_watch_command`**, **`serve_command`**, **`install_command`**: Custom commands for each operation (auto-detected from executor if None)
- **`http2`**: Enable HTTP/2 for proxy HTTP connections (better multiplexing, requires `h2` package). WebSocket traffic (HMR) uses a separate connection and is unaffected. Default: True.
- **`start_dev_server`**: Auto-start dev server process (default: True). Set to False to manage the dev server manually.
- **`is_react`**: Enable React Fast Refresh
    - Framework integration is controlled by `mode="framework"` (aliases: `mode="ssr"` / `mode="ssg"`).
- **`health_check`**: Enable health check for dev server startup
- **`detect_nodeenv`**: Detect and use nodeenv in virtualenv (opt-in)
- **`set_environment`**: Set Vite environment variables from config (default: True)
- **`set_static_folders`**: Automatically configure static file serving (default: True)
- **`csp_nonce`**: Content Security Policy nonce for inline scripts
- **`spa_handler`**: Auto-register catch-all SPA route when mode="spa" (default: True)

Python is the source of truth: The VitePlugin's `on_app_init()` method writes `.litestar.json` containing `assetUrl`, `bundleDir`, `resourceDir`, `staticDir`, `manifest`, `ssrOutDir`, `mode`, `proxyMode`, `host`, `port`, `executor`, type generation paths, and Litestar version. The JS plugin reads this file automatically - only `input` is required in `vite.config.ts`. Override only when you intentionally diverge from Python config.

### Core Modules

The backend is organized into specialized modules:

1. **Configuration & Plugin**:
    - `config.py`: `ViteConfig`, `SPAConfig`, `LoggingConfig`, and other configuration models
    - `plugin.py`: `VitePlugin` - main Litestar plugin registration

2. **Asset Management**:
    - `loader.py`: `ViteAssetLoader` - reads Vite manifest and serves assets
    - `deploy.py`: CDN deployment utilities using fsspec backends

3. **SPA Support**:
    - `handler.py` (exposes `AppHandler`): Serves SPA index.html in dev/production modes with both async and sync HTTP client support.
    - `html_transform.py`: HTML transformation functions (`inject_head_script`, `inject_body_content`, `inject_json_script`, `set_data_attribute`)
    - Key features: `is_initialized` property, `get_html(request)` for async contexts, `get_html_sync()` for sync contexts, cached HTML in production with `SPAConfig.cache_transformed_html`

4. **CLI & Tooling**:
    - `cli.py`: CLI entry points for Vite integration
    - `commands.py`: CLI command implementations
    - `executor.py`: `JSExecutor` abstraction for Node/Bun/Deno runtimes
    - `doctor.py`: Diagnostic utilities for troubleshooting
    - `codegen.py`: Code generation utilities (route typegen, etc.)

5. **Scaffolding**:
    - `scaffolding/`: Project template generation and initialization

6. **Inertia.js Integration** (`inertia/`):
    - `plugin.py`: `InertiaPlugin` - Litestar plugin with BlockingPortal for async DeferredProp resolution
    - `config.py`: `InertiaConfig` - configuration (moved to main config.py in v0.15)
    - `middleware.py`: `InertiaMiddleware` - handles Inertia protocol
    - `request.py`: `InertiaRequest` - enhanced request class with InertiaDetails/InertiaHeaders
    - `response.py`: `InertiaResponse` - Inertia page responses with props flattening
    - `routes.py`: `generate_js_routes` - route metadata generation for TypeScript
    - `helpers.py`: Helper functions (`share`, `lazy`, `defer`, `merge`, `error`, `flash`, `only`, `except_`, `clear_history`, `scroll_props`, `get_shared_props`, `extract_deferred_props`, `extract_merge_props`)
    - `exception_handler.py`: Exception handling for Inertia requests (`exception_to_http_response`, `create_inertia_exception_response`)
    - `_utils.py`: Internal utilities

## Frontend Architecture (TypeScript/Vite)

The core frontend code is located in `src/js/`. The `examples/` directory contains various frontend application examples (Vue, etc.).

### Directory Structure

```
src/js/src/
├── index.ts              # Main Vite plugin entry point
├── install-hint.ts       # Package manager detection utilities
├── litestar-meta.ts      # Runtime config loading from .litestar.json
├── dev-server-index.html # Dev server fallback HTML template
├── astro.ts              # Astro integration
├── nuxt.ts               # Nuxt module integration
├── sveltekit.ts          # SvelteKit integration
├── helpers/              # Frontend helper utilities
│   ├── index.ts          # Barrel export
│   ├── csrf.ts           # CSRF token utilities (getCsrfToken, csrfHeaders, csrfFetch)
│   ├── htmx.ts           # HTMX utilities (addDirective, registerHtmxExtension, setHtmxDebug, swapJson)
│   └── routes.ts         # Runtime route helpers (legacy)
├── shared/               # Shared utilities across modules
│   ├── bridge-schema.ts  # Bridge file type definitions
│   ├── debounce.ts       # Type-safe debounce utility
│   ├── logger.ts         # Logging utility
│   └── typegen-plugin.ts # Type generation plugin
└── inertia-helpers/      # Inertia.js specific helpers
    └── index.ts          # resolvePageComponent, unwrapPageProps
```

### Key Principles

- **Modularity**: Code is organized into modules and components.
- **Type Safety**: TypeScript is used throughout to ensure type safety.
- **Build Optimization**: Vite handles the development server (with HMR) and production builds. The configuration is in `vite.config.ts`.
- **DRY**: Shared utilities in `shared/` are used across framework integrations to avoid duplication.
- **Performance**: Route regex patterns are cached to avoid repeated compilation.

### Frontend Helpers (`litestar-vite-plugin/helpers`)

The helpers module provides utilities for working with Litestar routes and CSRF tokens from the frontend:

- **CSRF Utilities**: `getCsrfToken()`, `csrfHeaders()`, `csrfFetch()` - Get CSRF token from `window.__LITESTAR_CSRF__` or meta tag.
- **HTMX Utilities** (NEW in v0.15):
    - `addDirective(name, handler)` - Register custom HTMX directives
    - `registerHtmxExtension(name, extension)` - Register HTMX extensions
    - `setHtmxDebug(enabled)` - Enable/disable HTMX debug mode
    - `swapJson(target, json)` - Swap element content with JSON data

Route metadata is now generated as TypeScript at build time (see Type-Safe Routing below). Runtime route helpers are deprecated in favor of the generated routes.ts file.

### Type-Safe Routing (Generated)

When `types=TypeGenConfig(generate_routes=True)` is enabled (default), the Python backend generates route metadata that the Vite plugin uses to create a `routes.ts` file (default: `src/generated/routes.ts`). This provides fully typed routing:

```typescript
import { route } from '../generated/routes';

// Type-safe URL generation - checked at compile time
const url = route('users:get', { id: 123 });
```

The generated file exports:

- **`route(name, params)`**: Type-safe URL generator.
- **`routes`**: Dictionary of route metadata.
- **`RouteName`**: Union type of all available route names.
- **`RouteParams`**: Typed parameter interfaces for each route.
- **Semantic aliases**: When OpenAPI includes `format` (e.g. `uuid`, `date-time`), generated TS includes lightweight aliases (e.g. `type UUID = string`) and uses them in param types.
- **CSRF Helpers**: Re-exports `getCsrfToken`, `csrfHeaders`, `csrfFetch` for convenience.

This is the preferred routing method over the untyped runtime helpers.

Configuration:

- **Python**: `ViteConfig(types=TypeGenConfig(generate_routes=True, routes_ts_path=Path("src/generated/routes.ts")))`
- **Vite Plugin**: Reads `routes.json` metadata and generates TypeScript at build time

### Vite Plugin Configuration

The `litestar-vite-plugin` (default export in `src/js/src/index.ts`) configures Vite to work with Litestar.

When running via Litestar CLI, the plugin reads defaults from `.litestar.json` automatically. Only `input` is required:

```typescript
litestar({ input: ['src/main.ts'] })
```

Key options (auto-populated from `.litestar.json` when available):

- **`input`**: Entry points to compile (**required**).
- **`assetUrl`**: Base path for asset URLs (default: `/static/`).
- **`bundleDir`**: Output directory for assets (default: `public`).
- **`resourceDir`**: Source directory (default: `resources`).
- **`hotFile`**: Path to the hot file for HMR (default: `${bundleDir}/hot`).
- **`ssr`**: SSR entry point.
- **`ssrOutDir`**: Output directory for SSR bundle.
- **`refresh`**: Configuration for full page reload on file changes.
- **`detectTls`**: Utilize TLS certificates.
- **`autoDetectIndex`**: Automatically detect `index.html` (default: `true`).
- **`inertiaMode`**: Disable index auto-detection for Inertia apps (auto-detected from `.litestar.json`).
- **`transformOnServe`**: Apply HTML transformations in dev mode (default: `true`).
- **`types`**: Type generation configuration.
- **`executor`**: JavaScript runtime executor.

### Framework Integrations

The project provides integrations for multiple meta-frameworks:

#### Astro Integration (`astro.ts`)

Provides Vite integration for Astro projects with automatic HMR proxying and asset serving.

#### Nuxt Integration (`nuxt.ts`)

Nuxt 3 module that configures Vite for SSR/SPA modes with Litestar backend. Handles:

- HMR proxy setup
- SSR bundle configuration
- Build output coordination

#### SvelteKit Integration (`sveltekit.ts`)

SvelteKit adapter that bridges SvelteKit's SSR with Litestar. Features:

- Automatic adapter detection
- SSR HMR proxying
- Build artifact coordination

### Inertia.js Integration

For SPA-style applications, the project provides comprehensive Inertia.js support. The backend components are located in `src/py/litestar_vite/inertia/`, and frontend helpers are in `src/js/src/inertia-helpers/`.

#### Backend Components

- **`InertiaPlugin`**: Registers the Inertia integration with Litestar. Includes BlockingPortal lifespan for async DeferredProp resolution in type encoders.
- **`InertiaConfig`**: Configuration for Inertia integration
- **`InertiaResponse`**: Response class for rendering Inertia pages with automatic props flattening
- **`InertiaRequest`**: Enhanced request class with Inertia-specific properties (InertiaDetails, InertiaHeaders)
- **`InertiaMiddleware`**: Handles the Inertia protocol (headers, shared data)
- **Route handlers**: Use `component="ComponentName"` in route options (or `page=` as alias)
- **Exception handling**: Automatic error page rendering for Inertia requests via exception handlers

#### Frontend Helpers

- **`resolvePageComponent`**: Dynamic page component resolution for code-splitting
- **`unwrapPageProps`**: Utility to unwrap Litestar's `content` prop from Inertia page props
- **Re-exports**: Provides type-safe access to Inertia adapter functions

#### Helper Functions

- **`InertiaRedirect`**, **`InertiaExternalRedirect`**: Redirect handling within Inertia
- **`InertiaBack`**: Redirect to previous page
- **`share`**: Share data across all Inertia responses
- **`lazy`**: Define lazy-loaded props for performance (excluded from initial page load, sent on partial reloads)
- **`defer`**: Define deferred props (loaded after initial page render, Inertia v2 feature)
- **`merge`**: Define merge props for client-side state merging (Inertia v2 feature)
- **`error`**: Flash error messages to client
- **`flash`**: Flash messages to the next request
- **`only`**: Filter props to only include specified keys (PropFilter)
- **`except_`**: Filter props to exclude specified keys (PropFilter)
- **`clear_history`**: Clear browser history on next response (Inertia v2 feature)
- **`scroll_props`**: Generate pagination metadata for scroll regions (supports PaginationContainer protocol)
- **`get_shared_props`**: Retrieve shared props from request state
- **`extract_deferred_props`**: Extract deferred props from a dict
- **`extract_merge_props`**: Extract merge props from a dict
- **`create_inertia_exception_response`**: Create Inertia error responses
- **`exception_to_http_response`**: Convert exceptions to HTTP responses

#### Props Structure

Inertia props are flattened at the top level of the response. When your handler returns a dict, the keys are merged directly into `props`:

```python
@get("/", component="Dashboard")
def dashboard(request: Request) -> dict[str, Any]:
    return {
        "user": {"name": "Alice"},  # Becomes props.user
        "stats": {"total": 42}      # Becomes props.stats
    }
```

Non-dict content is wrapped under a `content` key:

```python
@get("/", component="UserProfile")
def profile(request: Request) -> str:
    return "Hello"  # Becomes props.content = "Hello"
```

Pagination unwrapping: If a handler returns a `PaginationContainer` (implements protocol with `items` attribute), InertiaResponse automatically unwraps it for Inertia scroll regions:

```python
@get("/users", component="UserList")
def user_list(request: Request) -> OffsetPagination[User]:
    return pagination_result  # Auto-unwrapped: props.items + scroll metadata
```

## Communication

- **Vite Manifest**: The `ViteAssetLoader` (`loader.py`) reads the `manifest.json` file generated by `vite build`. This manifest maps source asset names to their hashed output filenames.
- **Dev Server Proxy**: During development, the Litestar application does not serve the assets directly. Instead, it proxies requests to the Vite dev server, enabling Hot Module Replacement (HMR).
- **API Calls**: For non-Inertia pages, the frontend can make standard RESTful API calls to endpoints exposed by the Litestar backend.
- **Config Synchronization**: Python writes `.litestar.json` (via `set_environment()`) that the JS plugin reads as defaults, ensuring configuration consistency.

---

# 2. Development Workflow

**Version**: 0.15.0-beta.2 | **Updated**: 2025-12-14

This guide describes the standard development workflow for contributing to the `litestar-vite` project. It covers initial setup, daily development tasks, and the quality assurance process.

## 1. Initial Setup

All project tasks are managed through a `Makefile` and the `uv` Python package manager.

1. **Prerequisites**:
    - Python 3.10+
    - Node.js 20.19.0+ or 22.12.0+
    - `curl`

2. **Install `uv`**:
    If you don't have `uv` installed, you can install it with:

    ```bash
    curl -LsSf https://astral.sh/uv/install.sh | sh
    ```

3. **Install Project Dependencies**:
    Run the `install` target from the `Makefile`. This is the only command you need to get started.

    ```bash
    make install
    ```

    This command will:
    - Create a Python virtual environment (`.venv/`).
    - Install all required Python dependencies using `uv`.
    - Install all required Node.js dependencies using `npm`.
    - Set up the `pre-commit` hooks.

## 2. Daily Development

### Frontend directory conventions

- Inertia variants follow Laravel conventions and use `resources/` (e.g., `resources/main.tsx`, `resources/pages/*`).
- All other templates (React, Vue, Svelte, HTMX, Angular Vite, etc.) use `src/` for source files and keep `index.html` at the frontend root.
- You can relocate the entire frontend under a subfolder (e.g., `web/`) via `litestar assets init --frontend-dir web`; generated files (package.json, vite.config.ts, src/…) will be placed there.
- When configuring `VitePlugin` manually for non-Inertia templates, set `paths.resource_dir="src"` (default for scaffolds). For Inertia templates, keep `resources/`.

### Running the Development Server

To work on an example application (like the `vue` one), run Litestar and let it manage Vite for you (single port by default):

- **Run Litestar App (starts/proxies Vite)**:

    ```bash
    uv run litestar --app examples.vue.app:app run --reload
    ```

- **Two-port option (start Vite yourself)**:

    ```bash
    uv run litestar --app examples.vue.app:app assets serve
    uv run litestar --app examples.vue.app:app run --reload
    ```

- **Production Server (SSR)**:

    ```bash
    uv run litestar --app examples.sveltekit.app:app assets serve --production
    ```

### Running Tests

As you make changes, you should run tests to ensure you haven't introduced any regressions.

```bash
# Run the full test suite (Python and JS)
make test

# Run only Python tests
pytest src/py/tests/

# Run only JS tests
npm run test --workspace=src/js
```

### Code Quality

Before committing, ensure your code meets the project's quality standards. The pre-commit hooks will run these checks automatically, but you can also run them manually.

```bash
# Run all linters and type checkers
make lint

# Auto-format your code
make fix
```

## 3. Committing and Pre-Commit Hooks

This project uses `pre-commit` to enforce code quality at the time of commit. When you run `git commit`, a series of automated checks (linting, formatting, type-checking) will execute.

If any of the checks fail, the commit will be aborted. You must fix the reported issues and re-add the files to your commit. For formatting issues, the hooks may fix them for you automatically; in this case, you just need to `git add` the modified files and commit again.

## 4. AI Agent Workflow

For significant features, this project uses an AI agent system with specialized agents for different phases.

See `AGENTS.md` and `CLAUDE.md` for detailed documentation on:

- `/prd [feature]` - Create Product Requirements Documents
- `/implement [slug]` - Implement features from PRDs
- `/test [slug]` - Create comprehensive test suites
- `/review [slug]` - Quality gates and documentation
- Specialized subagents: `prd`, `expert`, `testing`, `docs-vision`, `sync-guides`

The agent system guides features through planning, implementation, testing, and review, ensuring all quality gates are met.

## 5. Release Workflow

### Standard Release

For regular releases (patch, minor, major):

```bash
# Ensure clean working tree
git status

# Bump version (choose one)
make release bump=patch   # 0.14.0 → 0.14.1
make release bump=minor   # 0.14.0 → 0.15.0
make release bump=major   # 0.14.0 → 1.0.0

# Push to main
git push origin main

# Create GitHub release
gh release create v0.15.0 --title "v0.15.0" --generate-notes
```

### Pre-releases (Alpha/Beta/RC)

For testing breaking changes with a limited audience before stable release:

```bash
# Start alpha
make pre-release version=0.15.0-alpha.1

# Iterate on alpha
make pre-release version=0.15.0-alpha.2

# Progress to beta
make pre-release version=0.15.0-beta.1

# Release candidate
make pre-release version=0.15.0-rc.1

# Push and create pre-release
git push origin HEAD
gh release create v0.15.0-alpha.1 --prerelease --title "v0.15.0-alpha.1"
```

**Distribution:**

- PyPI: Pre-release versions are automatically marked (users need `pip install --pre` or explicit version)
- npm: Published with `next` tag (users install via `npm install litestar-vite-plugin@next`)

**Finalizing:** When ready for stable, run `make release bump=minor` (or `patch` from RC).

---

# 3. Configuration Precedence

**Version**: 0.15.0-beta.2 | **Updated**: 2025-12-14

```
┌─────────────────────┐
│   Python ViteConfig │
│   (VitePlugin)      │
└─────────┬───────────┘
          │ on_app_init()
          ▼
┌─────────────────────┐
│   .litestar.json    │
│   (Bridge File)     │
└─────────┬───────────┘
          │ loadPythonDefaults()
          ▼
┌─────────────────────┐    ┌─────────────────────┐
│   vite.config.ts    │───▶│  Resolved Config    │
│   (User TS Config)  │    │  + Validation       │
└─────────────────────┘    └─────────────────────┘
```

## Precedence Chain

**`vite.config.ts` > `.litestar.json` > hardcoded defaults**

1. **vite.config.ts** - Explicit user configuration takes highest priority
2. **.litestar.json** - Python-generated bridge file provides defaults
3. **Hardcoded defaults** - Built-in fallbacks when neither is available

## The Bridge File (`.litestar.json`)

When Litestar starts, it writes a `.litestar.json` file containing shared configuration.

## Field Classification

### Shared Fields (in `.litestar.json`)

These fields are meaningful to both Python and TypeScript:

| Field | Python Name | JSON/TypeScript Name | Description |
|-------|-------------|---------------------|-------------|
| Asset URL | `asset_url` | `assetUrl` | Base URL for assets |
| Bundle Directory | `bundle_dir` | `bundleDir` | Build output directory |
| Resource Directory | `resource_dir` | `resourceDir` | Source assets directory |
| Static Directory | `static_dir` | `staticDir` | Static assets directory |
| Hot File | `hot_file` | `hotFile` | Dev server URL file |
| Manifest Name | `manifest_name` | `manifest` | Build manifest filename |
| Mode | `mode` | `mode` | Operation mode |
| Proxy Mode | `proxy_mode` | `proxyMode` | Dev proxy configuration |
| Host | `host` | `host` | Dev server host |
| Port | `port` | `port` | Dev server port |
| SSR Output Dir | `ssr_output_dir` | `ssrOutDir` | SSR build output |
| Executor | `runtime.executor` | `executor` | Package manager command |
| Logging | `logging` | `logging` | Logging configuration |

### Python-Only Fields

These are configured in Python and not exposed to TypeScript:

- `DeployConfig` - CDN deployment settings
- `SPAConfig` - Single-page app settings
- `InertiaConfig` - Inertia.js integration settings
- `InertiaTypeGenConfig` - Inertia type generation
- `InertiaSSRConfig` - Inertia SSR settings
- `RuntimeConfig.run_command`, `build_command` etc.
- `ExternalDevServer`, `PaginationContainer`, `guards`, etc.

### TypeScript-Only Fields

These are configured in `vite.config.ts` only:

- `input`, `refresh`, `detectTls`, `autoDetectIndex`, `transformOnServe`, `types.debounce`, plugins, aliases.

## Best Practices

1. **Let Python Drive Shared Config**: Configure shared settings in Python's `ViteConfig`.
2. **Keep vite.config.ts Minimal**: Only specify TypeScript-specific options.
3. **Override Only When Necessary**: If you need to override Python defaults in TypeScript.
4. **Run Litestar First in Development**: The bridge file is created when Litestar starts.

---

# 4. Testing Guide

**Version**: 0.15.0-beta.2 | **Updated**: 2025-12-14

This guide provides instructions and best practices for writing and running tests in the `litestar-vite` project.

## Overview

The project uses a dual testing strategy for its Python backend and TypeScript frontend.

- **Backend (Python)**: [pytest](https://docs.pytest.org/) is the primary framework for all Python tests.
- **Frontend (TypeScript)**: [Vitest](https://vitest.dev/) is used for tests related to the core JavaScript/TypeScript library.

The full test suite can be run with a single command: `make test`.

## Backend Testing (pytest)

Python tests are located in `src/py/tests/`.

### Test Types

1. **Unit Tests (`src/py/tests/unit/`)**: Focus on individual components (functions, classes) in isolation.
2. **Integration Tests (`src/py/tests/integration/`)**: Verify the interaction between multiple components.

### Key Practices

- **Function-Based Tests**: All tests **must** be function-based. Do not use class-based tests.
- **Fixtures**: Use `pytest` fixtures for reusable setup.
- **Async Tests**: Mark `async` test functions with `@pytest.mark.asyncio`.
- **Coverage**: Aim for at least 90% test coverage for any new or modified code.

## Frontend Testing (Vitest)

The core TypeScript library tests are located in `src/js/tests/`.

### Running Frontend Tests

```bash
# Navigate to the JS directory
cd src/js

# Run the tests
npm run test
```

## End-to-End (E2E) Testing

E2E tests validate the complete developer experience by running actual servers.

### Critical: Use Litestar CLI Commands

**ALWAYS use `litestar assets` commands instead of npm/node directly in tests!**

---

# 5. Code Style Guide

**Version**: 0.15.0-beta.2 | **Updated**: 2025-12-14

This document defines the code style and quality standards for both the Python backend and TypeScript frontend.

## Python Code Style

- **Formatter**: [Ruff](https://docs.astral.sh/ruff/)
- **Linter**: [Ruff](https://docs.astral.sh/ruff/)
- **Type Checking**: [MyPy](http://mypy-lang.org/)

### Key Standards

1. **Type Hinting**: PEP 604 (`list[str]`, `str | None`). Do **not** use `from __future__ import annotations`.
2. **Docstrings**: Google style.
3. **Imports**: Sorted by Ruff.

## TypeScript/JavaScript Code Style

- **Formatter**: Biome
- **Linter**: Biome

### Key Standards

1. **Formatting**: Follow `biome.json`.
2. **Language Features**: Modern ECMAScript features, TypeScript for all new code.

---

# 6. API Reference

## Python API (`litestar_vite`)

### `VitePlugin`
The main entry point for integrating Vite with Litestar.

```python
class VitePlugin(InitPluginProtocol, CLIPlugin):
    def __init__(
        self,
        config: "ViteConfig | None" = None,
        asset_loader: "ViteAssetLoader | None" = None,
        static_files_config: "StaticFilesConfig | None" = None,
    ) -> None: ...
```

### `ViteConfig`
Root configuration class.

```python
@dataclass
class ViteConfig:
    mode: "Literal['spa', 'template', 'htmx', 'hybrid', 'inertia', 'framework', 'ssr', 'ssg', 'external'] | None" = None
    paths: PathConfig = field(default_factory=PathConfig)
    runtime: RuntimeConfig = field(default_factory=RuntimeConfig)
    types: "TypeGenConfig | bool | None" = None
    inertia: "InertiaConfig | bool | None" = None
    spa: "SPAConfig | bool | None" = None
    logging: "LoggingConfig | bool | None" = None
    dev_mode: bool = False
    base_url: "str | None" = None
    deploy: "DeployConfig | bool" = False
    guards: "Sequence[Guard] | None" = None
    exclude_static_from_auth: bool = True
    spa_path: "str | None" = None
    include_root_spa_paths: bool = False
```

### `InertiaPlugin`
Plugin for Inertia.js support.

```python
class InertiaPlugin(InitPluginProtocol):
    def __init__(self, config: "InertiaConfig") -> "None": ...
```

### `InertiaResponse`
Response class for Inertia requests, handling props flattening and content wrapping.

```python
class InertiaResponse(Response[T]):
    def __init__(
        self,
        content: T,
        status_code: int = 200,
        component: str | None = None,
        props: dict[str, Any] | None = None,
        # ... other Response args
    ) -> None: ...
```

## TypeScript API (`litestar-vite-plugin`)

### `litestar(config: PluginConfig)`
Vite plugin function.

```typescript
export default function litestar(config: string | string[] | PluginConfig): any[]
```

**`PluginConfig` Interface**:
- `input`: Entry points (string | string[]).
- `assetUrl`: Base asset URL (default: '/static/').
- `bundleDir`: Output dir (default: 'public/dist').
- `resourceDir`: Source dir (default: 'src').
- `hotFile`: Path to hot file.
- `ssr`: SSR entry point.
- `ssrOutDir`: SSR output dir.
- `refresh`: Full page reload config.
- `detectTls`: Auto-detect HTTPS.
- `autoDetectIndex`: Auto-detect index.html.
- `inertiaMode`: Disable index auto-detection for Inertia.
- `types`: Type generation config (boolean | "auto" | TypesConfig).
- `executor`: JS runtime ('node', 'bun', etc.).
