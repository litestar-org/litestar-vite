# Litestar Vite: Comprehensive Documentation

**Version**: 0.16.0
**Project**: litestar-vite

Seamless integration between Litestar and Vite with Inertia.js support.
This document contains the full context of the project, including architecture, guides, and API reference.

---

# 1. Architecture Guide

**Version**: 0.16.0 | **Updated**: 2026-01-04

This document outlines the architectural patterns and conventions used in the `litestar-vite` project.

## Overview

The project follows a hybrid architecture combining a Python backend with a modern TypeScript frontend.

- **Backend**: Built with [Litestar](https://litestar.dev/) 2.7.0+, a high-performance, asynchronous ASGI framework. Requires Python 3.10+.
- **Frontend**: Managed by [Vite](https://vitejs.dev/) 6.x or 7.x, a next-generation frontend build tool. Requires Node.js 20.19.0+ or 22.12.0+.
- **Integration**: The backend and frontend are connected via a manifest file generated by Vite, allowing the Litestar backend to serve the correct, hash-named JS and CSS assets. The project also includes comprehensive support for [Inertia.js](https://inertiajs.com/) to build single-page applications with server-side routing.

## Backend Architecture (Python/Litestar)

The backend code is located in `src/py/litestar_vite/`.

### Key Principles

- **Asynchronous by Default**: All I/O-bound operations (database access, API calls) should be `async` to leverage Litestar's performance benefits.
- **Dependency Injection**: Litestar's dependency injection is used to manage resources like database sessions and services. Dependencies should be defined in a reusable way.
- **Configuration**: Configuration is managed through dataclasses in `config/` modules, allowing for type-safe and environment-aware settings.
- **Modular Design**: Core functionality is split across specialized modules (config, plugin, loader, SPA handler, Inertia integration, etc.).

### Configuration (`ViteConfig`)

The `ViteConfig` class in `config/` (imported as `litestar_vite.config`) controls the integration behavior. It uses a modular structure with sub-configs:

- **`PathConfig`**: File system paths (root, bundle_dir, resource_dir, static_dir, asset_url, ssr_output_dir, manifest_name, hot_file)
- **`RuntimeConfig`**: Execution settings (dev_mode, proxy_mode, external_dev_server, http2, start_dev_server)
- **`TypeGenConfig`**: Type generation settings (output, openapi_path, routes_path, routes_ts_path, page_props_path, schemas_ts_path, generate_zod, generate_sdk, generate_routes, generate_page_props, generate_schemas, global_route, fallback_type, type_import_paths)
- **`InertiaConfig`**: Inertia.js settings (root_template, component_opt_keys, redirect_unauthorized_to, redirect_404, extra_static_page_props, extra_session_page_props, encrypt_history, type_gen, ssr, use_script_element, precognition).
- **`InertiaTypeGenConfig`**: Inertia type generation settings (include_default_auth, include_default_flash)
- **`InertiaSSRConfig`**: Inertia Server-Side Rendering settings (enabled, url, timeout)
- **`SPAConfig`**: SPA transformation settings (inject_csrf, cache_transformed_html, app_selector, csrf_var_name)
- **`LoggingConfig`**: Logging configuration (level, show_paths_absolute, suppress_npm_output, suppress_vite_banner, timestamps)
- **`DeployConfig`**: CDN deployment settings (storage_backend, delete_orphaned, content_types, include_manifest)
- **`ExternalDevServer`**: External dev server configuration (target, command, build_command, http2, enabled)
- **`PaginationContainer`**: Protocol for pagination containers (must implement `items` attribute)
- **`ViteConfig`**: Root configuration. Key fields include:
    - **`mode`**: Serving mode - "spa", "template", "htmx", "hybrid", "framework", "ssr", "ssg", or "external"
    - **`guards`**: Custom guards for the SPA catch-all route
    - **`exclude_static_from_auth`**: Exclude static file routes from authentication (default: True)
    - **`spa_path`**: Path where the SPA handler serves index.html (default: "/")
    - **`include_root_spa_paths`**: Register SPA routes at root even when spa_path is non-root (default: False)

Key `RuntimeConfig` options:

- **`dev_mode`**: Enable development mode with HMR/watch
- **`proxy_mode`**: Proxy handling mode:
    - "vite" (default): Proxy Vite assets only (allow list - SPA mode)
    - "direct": Expose Vite port directly (no proxy)
    - "proxy": Proxy everything except Litestar routes (deny list - framework mode)
    - None: No proxy (production mode)
- **`external_dev_server`**: External dev server config (string URL or `ExternalDevServer` with custom commands, http2 flag, enabled flag)
- **`host`**, **`port`**, **`protocol`**: Vite dev server connection details
- **`executor`**: JavaScript runtime (node, bun, deno, yarn, pnpm)
- **`run_command`**, **`build_command`**, **`build_watch_command`**, **`serve_command`**, **`install_command`**: Custom commands for each operation (auto-detected from executor if None)
- **`http2`**: Enable HTTP/2 for proxy HTTP connections (better multiplexing, requires `h2` package). WebSocket traffic (HMR) uses a separate connection and is unaffected. Default: True.
- **`start_dev_server`**: Auto-start dev server process (default: True). Set to False to manage the dev server manually.
- **`is_react`**: Enable React Fast Refresh
    - Framework integration is controlled by `mode="framework"` (aliases: `mode="ssr"` / `mode="ssg"`).
- **`health_check`**: Enable health check for dev server startup
- **`detect_nodeenv`**: Detect and use nodeenv in virtualenv (opt-in)
- **`set_environment`**: Set Vite environment variables and write `.litestar.json` from config (default: True)
- **`set_static_folders`**: Automatically configure static file serving (default: True)
- **`csp_nonce`**: Content Security Policy nonce for inline scripts
- **`spa_handler`**: Auto-register catch-all SPA route when mode="spa" (default: True)
- **`trusted_proxies`**: Trusted proxy hosts/CIDRs for ProxyHeadersMiddleware (default: None)

Python is the source of truth: The VitePlugin's `on_app_init()` method writes `.litestar.json` containing `assetUrl`, `deployAssetUrl`, `bundleDir`, `resourceDir`, `staticDir`, `hotFile`, `manifest`, `ssrOutDir`, `mode`, `proxyMode`, `host`, `port`, `executor`, `logging`, `spa`, type generation settings, and Litestar version. The JS plugin reads this file automatically - only `input` is required in `vite.config.ts`. Override only when you intentionally diverge from Python config.

### Core Modules

The backend is organized into specialized modules:

1. **Configuration & Plugin**:
    - `config/`: `ViteConfig`, `SPAConfig`, `LoggingConfig`, and other configuration models
    - `plugin/`: `VitePlugin` - main Litestar plugin registration

2. **Asset Management**:
    - `loader.py`: `ViteAssetLoader` - reads Vite manifest and serves assets
    - `deploy.py`: CDN deployment utilities using fsspec backends

3. **SPA Support**:
    - `handler/` (exposes `AppHandler`): Serves SPA index.html in dev/production modes with both async and sync HTTP client support.
    - `html_transform.py`: HTML transformation functions (`inject_head_script`, `inject_body_content`, `inject_json_script`, `set_data_attribute`)
    - Key features: `is_initialized` property, `get_html(request)` for async contexts, `get_html_sync()` for sync contexts, cached HTML in production with `SPAConfig.cache_transformed_html`

4. **CLI & Tooling**:
    - `cli.py`: CLI entry points for Vite integration
    - `commands.py`: CLI command implementations
    - `executor.py`: `JSExecutor` abstraction for Node/Bun/Deno runtimes
    - `doctor.py`: Diagnostic utilities for troubleshooting
    - `codegen/`: Code generation utilities (route typegen, etc.)

5. **Scaffolding**:
    - `scaffolding/`: Project template generation and initialization
    - **Supported Templates**:
        - `react`: React 18+ with TypeScript
        - `react-router`: React + React Router
        - `react-tanstack`: React + TanStack Router
        - `react-inertia`: React + Inertia.js
        - `vue`: Vue 3
        - `vue-inertia`: Vue + Inertia.js
        - `svelte`: Svelte 5
        - `svelte-inertia`: Svelte + Inertia.js
        - `sveltekit`: SvelteKit
        - `nuxt`: Nuxt 3
        - `astro`: Astro
        - `htmx`: HTMX
        - `angular`: Angular (Vite)
        - `angular-cli`: Angular CLI

6. **Inertia.js Integration** (`inertia/`):
    - `plugin.py`: `InertiaPlugin` - Litestar plugin with BlockingPortal for async DeferredProp resolution
    - `config/`: `InertiaConfig` - configuration (moved to main config module in v0.15)
    - `middleware.py`: `InertiaMiddleware` - handles Inertia protocol
    - `request.py`: `InertiaRequest` - enhanced request class with InertiaDetails/InertiaHeaders
    - `response.py`: `InertiaResponse` - Inertia page responses with props flattening
    - `routes.py`: `generate_js_routes` - route metadata generation for TypeScript
    - `helpers.py`: Helper functions (`share`, `lazy`, `defer`, `merge`, `error`, `flash`, `only`, `except_`, `clear_history`, `scroll_props`, `get_shared_props`, `extract_deferred_props`, `extract_merge_props`)
    - `exception_handler.py`: Exception handling for Inertia requests (`exception_to_http_response`, `create_inertia_exception_response`)
    - `_utils.py`: Internal utilities

## Frontend Architecture (TypeScript/Vite)

The core frontend code is located in `src/js/`. The `examples/` directory contains various frontend application examples (Vue, etc.).

### Directory Structure

```
src/js/src/
├── index.ts              # Main Vite plugin entry point
├── install-hint.ts       # Package manager detection utilities
├── litestar-meta.ts      # Runtime config loading from .litestar.json
├── dev-server/           # Dev server fallback page (built to dist/js/)
│   ├── index.html        # Source HTML template
│   ├── styles.css        # Tailwind CSS source
│   └── vite.config.ts    # Build config for singlefile output
├── server-starting/      # Server starting page (built to Python wheel)
│   ├── index.html        # Source HTML template
│   ├── styles.css        # Tailwind CSS source
│   └── vite.config.ts    # Build config for singlefile output
├── astro.ts              # Astro integration
├── nuxt.ts               # Nuxt module integration
├── sveltekit.ts          # SvelteKit integration
├── helpers/              # Frontend helper utilities
│   ├── index.ts          # Barrel export
│   ├── csrf.ts           # CSRF token utilities (getCsrfToken, csrfHeaders, csrfFetch)
│   ├── htmx.ts           # HTMX utilities (addDirective, registerHtmxExtension, setHtmxDebug, swapJson)
│   └── routes.ts         # Runtime route helpers (legacy)
├── shared/               # Shared utilities across modules
│   ├── bridge-schema.ts       # Bridge file type definitions
│   ├── constants.ts           # Shared defaults (typegen/output)
│   ├── format-path.ts         # Path normalization
│   ├── network.ts             # Host normalization utilities
│   ├── debounce.ts            # Type-safe debounce utility
│   ├── logger.ts              # Logging utility
│   ├── write-if-changed.ts    # Deterministic file writes
│   ├── emit-page-props-types.ts # Inertia page-props types generator
│   ├── emit-schemas-types.ts  # schemas.ts helper generator
│   ├── typegen-cache.ts       # Type generation cache
│   ├── typegen-core.ts        # hey-api pipeline wiring
│   └── typegen-plugin.ts      # Type generation plugin
└── inertia-helpers/      # Inertia.js specific helpers
    └── index.ts          # resolvePageComponent, unwrapPageProps
```

### Key Principles

- **Modularity**: Code is organized into modules and components.
- **Type Safety**: TypeScript is used throughout to ensure type safety.
- **Build Optimization**: Vite handles the development server (with HMR) and production builds. The configuration is in `vite.config.ts`.
- **DRY**: Shared utilities in `shared/` are used across framework integrations to avoid duplication.
- **Performance**: Route regex patterns are cached to avoid repeated compilation.

### Frontend Helpers (`litestar-vite-plugin/helpers`)

The helpers module provides utilities for working with Litestar routes and CSRF tokens from the frontend:

- **CSRF Utilities**: `getCsrfToken()`, `csrfHeaders()`, `csrfFetch()` - Get CSRF token from `window.__LITESTAR_CSRF__` or meta tag.
- **HTMX Utilities** (NEW in v0.15):
    - `addDirective(name, handler)` - Register custom HTMX directives
    - `registerHtmxExtension(name, extension)` - Register HTMX extensions
    - `setHtmxDebug(enabled)` - Enable/disable HTMX debug mode
    - `swapJson(target, json)` - Swap element content with JSON data

Typed route helpers are generated by the Python backend (see Type-Safe Routing below). Runtime route helpers are deprecated in favor of the generated routes.ts file.

### Type-Safe Routing (Generated)

When `types=TypeGenConfig(generate_routes=True)` is enabled (default), the Python backend generates `routes.ts` (default: `src/generated/routes.ts`) alongside `routes.json`. This provides fully typed routing:

```typescript
import { route } from '../generated/routes';

// Type-safe URL generation - checked at compile time
const url = route('users:get', { id: 123 });
```

The generated file exports:

- **`route(name, params)`**: Type-safe URL generator.
- **`routes`**: Dictionary of route metadata.
- **`RouteName`**: Union type of all available route names.
- **`RouteParams`**: Typed parameter interfaces for each route.
- **Semantic aliases**: When OpenAPI includes `format` (e.g. `uuid`, `date-time`), generated TS includes lightweight aliases (e.g. `type UUID = string`) and uses them in param types.
- **CSRF Helpers**: Re-exports `getCsrfToken`, `csrfHeaders`, `csrfFetch` for convenience.

This is the preferred routing method over the untyped runtime helpers.

Configuration:

- **Python**: `ViteConfig(types=TypeGenConfig(generate_routes=True, routes_ts_path=Path("src/generated/routes.ts")))`
- **Vite Plugin**: Reads `routes.json` metadata to generate `schemas.ts` helpers (does not generate `routes.ts`)

### Vite Plugin Configuration

The `litestar-vite-plugin` (default export in `src/js/src/index.ts`) configures Vite to work with Litestar.

When running via Litestar CLI, the plugin reads defaults from `.litestar.json` automatically. Only `input` is required:

```typescript
litestar({ input: ['src/main.ts'] })
```

Key options (auto-populated from `.litestar.json` when available):

- **`input`**: Entry points to compile (**required**).
- **`assetUrl`**: Base path for asset URLs (default: `/static/`).
- **`deployAssetUrl`**: Asset URL used only during production builds (from Python `DeployConfig.asset_url`).
- **`bundleDir`**: Output directory for assets (default: `public`).
- **`resourceDir`**: Source directory (default: `src`; Inertia templates typically use `resources`).
- **`staticDir`**: Static public assets directory (default: `${resourceDir}/public` to avoid `publicDir`/`outDir` collisions).
- **`hotFile`**: Path to the hot file for HMR (default: `${bundleDir}/hot`).
- **`ssr`**: SSR entry point.
- **`ssrOutDir`**: Output directory for SSR bundle.
- **`refresh`**: Configuration for full page reload on file changes.
- **`detectTls`**: Utilize TLS certificates.
- **`autoDetectIndex`**: Automatically detect `index.html` (default: `true`).
- **`inertiaMode`**: Disable index auto-detection for Inertia apps (auto-detected from `.litestar.json` when mode is `hybrid`/`inertia`).
- **`transformOnServe`**: Apply HTML transformations in dev mode.
- **`types`**: Type generation configuration (`"auto"`/`undefined` reads from `.litestar.json`; fields include `output`, `openapiPath`, `routesPath`, `pagePropsPath`, `schemasTsPath`, `generateRoutes`, `generatePageProps`, `generateSchemas`).
- **`executor`**: JavaScript runtime executor.

### Framework Integrations

The project provides integrations for multiple meta-frameworks:

#### Astro Integration (`astro.ts`)

Provides Vite integration for Astro projects with automatic HMR proxying and asset serving.

#### Nuxt Integration (`nuxt.ts`)

Nuxt 3 module that configures Vite for SSR/SPA modes with Litestar backend. Handles:

- HMR proxy setup
- SSR bundle configuration
- Build output coordination

#### SvelteKit Integration (`sveltekit.ts`)

SvelteKit adapter that bridges SvelteKit's SSR with Litestar. Features:

- Automatic adapter detection
- SSR HMR proxying
- Build artifact coordination

### Inertia.js Integration

For SPA-style applications, the project provides comprehensive Inertia.js support. The backend components are located in `src/py/litestar_vite/inertia/`, and frontend helpers are in `src/js/src/inertia-helpers/`.

#### Backend Components

- **`InertiaPlugin`**: Registers the Inertia integration with Litestar. Includes BlockingPortal lifespan for async DeferredProp resolution in type encoders.
- **`InertiaConfig`**: Configuration for Inertia integration
- **`InertiaResponse`**: Response class for rendering Inertia pages with automatic props flattening
- **`InertiaRequest`**: Enhanced request class with Inertia-specific properties (InertiaDetails, InertiaHeaders)
- **`InertiaMiddleware`**: Handles the Inertia protocol (headers, shared data)
- **Route handlers**: Use `component="ComponentName"` in route options (or `page=` as alias)
- **Exception handling**: Automatic error page rendering for Inertia requests via exception handlers

#### Frontend Helpers

- **`resolvePageComponent`**: Dynamic page component resolution for code-splitting
- **`unwrapPageProps`**: Utility to unwrap Litestar's `content` prop from Inertia page props
- **Re-exports**: Provides type-safe access to Inertia adapter functions

#### Helper Functions

- **`InertiaRedirect`**, **`InertiaExternalRedirect`**: Redirect handling within Inertia
- **`InertiaBack`**: Redirect to previous page
- **`share`**: Share data across all Inertia responses
- **`lazy`**: Define lazy-loaded props for performance (excluded from initial page load, sent on partial reloads)
- **`defer`**: Define deferred props (loaded after initial page render, Inertia v2 feature)
- **`merge`**: Define merge props for client-side state merging (Inertia v2 feature)
- **`error`**: Flash error messages to client
- **`flash`**: Flash messages to the next request
- **`only`**: Filter props to only include specified keys (PropFilter)
- **`except_`**: Filter props to exclude specified keys (PropFilter)
- **`clear_history`**: Clear browser history on next response (Inertia v2 feature)
- **`scroll_props`**: Generate pagination metadata for scroll regions (supports PaginationContainer protocol)
- **`get_shared_props`**: Retrieve shared props from request state
- **`extract_deferred_props`**: Extract deferred props from a dict
- **`extract_merge_props`**: Extract merge props from a dict
- **`create_inertia_exception_response`**: Create Inertia error responses
- **`exception_to_http_response`**: Convert exceptions to HTTP responses

#### Props Structure

Inertia props are flattened at the top level of the response. When your handler returns a dict, the keys are merged directly into `props`:

```python
@get("/", component="Dashboard")
def dashboard(request: Request) -> dict[str, Any]:
    return {
        "user": {"name": "Alice"},  # Becomes props.user
        "stats": {"total": 42}      # Becomes props.stats
    }
```

Non-dict content is wrapped under a `content` key:

```python
@get("/", component="UserProfile")
def profile(request: Request) -> str:
    return "Hello"  # Becomes props.content = "Hello"
```

Pagination unwrapping: If a handler returns a `PaginationContainer` (implements protocol with `items` attribute), InertiaResponse automatically unwraps it for Inertia scroll regions:

```python
@get("/users", component="UserList")
def user_list(request: Request) -> OffsetPagination[User]:
    return pagination_result  # Auto-unwrapped: props.items + scroll metadata
```

## Communication

- **Vite Manifest**: The `ViteAssetLoader` (`loader.py`) reads the `manifest.json` file generated by `vite build`. This manifest maps source asset names to their hashed output filenames.
- **Dev Server Proxy**: During development, the Litestar application does not serve the assets directly. Instead, it proxies requests to the Vite dev server, enabling Hot Module Replacement (HMR).
- **API Calls**: For non-Inertia pages, the frontend can make standard RESTful API calls to endpoints exposed by the Litestar backend.
- **Config Synchronization**: Python writes `.litestar.json` (via `set_environment()`) that the JS plugin reads as defaults, ensuring configuration consistency.

## Example Applications

The `examples/` directory contains working examples demonstrating various integration patterns:

### Framework Examples

- **`angular/`**: Angular 18+ with signals integration
- **`angular-cli/`**: Angular CLI-based setup
- **`astro/`**: Astro static site integration
- **`nuxt/`**: Nuxt 3 SSR/SPA integration
- **`sveltekit/`**: SvelteKit SSR integration
- **`svelte/`**: Standalone Svelte 5 with runes

### React Examples

- **`react/`**: Basic React SPA
- **`react-inertia/`**: React with Inertia.js
- **`react-inertia-jinja/`**: React + Inertia with Jinja2 templates

### Vue Examples

- **`vue/`**: Basic Vue 3 SPA
- **`vue-inertia/`**: Vue 3 with Inertia.js (Composition API)
- **`vue-inertia-jinja/`**: Vue + Inertia with Jinja2 templates

### Templating & HTMX

- **`jinja-htmx/`**: HTMX hypermedia integration with Jinja2 templates

Each example includes its own `package.json`, Vite configuration, and demonstrates best practices for that particular stack.

---

# 2. Development Workflow

**Version**: 0.16.0 | **Updated**: 2026-01-04

This guide describes the standard development workflow for contributing to the `litestar-vite` project. It covers initial setup, daily development tasks, and the quality assurance process.

## 1. Initial Setup

All project tasks are managed through a `Makefile` and the `uv` Python package manager.

1. **Prerequisites**:
    - Python 3.10+
    - Node.js 20.19.0+ or 22.12.0+
    - `curl`

2. **Install `uv`**:
    If you don't have `uv` installed, you can install it with:

    ```bash
    curl -LsSf https://astral.sh/uv/install.sh | sh
    ```

3. **Install Project Dependencies**:
    Run the `install` target from the `Makefile`. This is the only command you need to get started.

    ```bash
    make install
    ```

    This command will:
    - Create a Python virtual environment (`.venv/`).
    - Install all required Python dependencies using `uv`.
    - Install all required Node.js dependencies using `npm`.
    - Set up the `pre-commit` hooks.

## 2. Daily Development

### Frontend directory conventions

- Inertia variants follow Laravel conventions and use `resources/` (e.g., `resources/main.tsx`, `resources/pages/*`).
- All other templates (React, Vue, Svelte, HTMX, Angular Vite, etc.) use `src/` for source files and keep `index.html` at the frontend root.
- You can relocate the entire frontend under a subfolder (e.g., `web/`) via `litestar assets init --frontend-dir web`; generated files (package.json, vite.config.ts, src/…) will be placed there.
- When configuring `VitePlugin` manually for non-Inertia templates, set `paths.resource_dir="src"` (default for scaffolds). For Inertia templates, keep `resources/`.

### Running the Development Server

To work on an example application (like the `vue` one), run Litestar and let it manage Vite for you (single port by default):

- **Run Litestar App (starts/proxies Vite)**:

    ```bash
    uv run litestar --app examples.vue.app:app run --reload
    ```

- **Two-port option (start Vite yourself)**:

    ```bash
    uv run litestar --app examples.vue.app:app assets serve
    uv run litestar --app examples.vue.app:app run --reload
    ```

- **Production Server (SSR)**:

    ```bash
    uv run litestar --app examples.sveltekit.app:app assets serve --production
    ```

### Running Tests

As you make changes, you should run tests to ensure you haven't introduced any regressions.

```bash
# Run the full test suite (Python and JS)
make test

# Run only Python tests
pytest src/py/tests/

# Run only JS tests
npm run test
```

### Code Quality

Before committing, ensure your code meets the project's quality standards. The pre-commit hooks will run these checks automatically, but you can also run them manually.

```bash
# Run all linters and type checkers
make lint

# Auto-format your code
make fix
```

## 3. Committing and Pre-Commit Hooks

This project uses `pre-commit` to enforce code quality at the time of commit. When you run `git commit`, a series of automated checks (linting, formatting, type-checking) will execute.

If any of the checks fail, the commit will be aborted. You must fix the reported issues and re-add the files to your commit. For formatting issues, the hooks may fix them for you automatically; in this case, you just need to `git add` the modified files and commit again.

## 4. AI Agent Workflow

For significant features, this project uses an AI agent system with specialized agents for different phases.

See `AGENTS.md` and `CLAUDE.md` for detailed documentation on:

- `/prd [feature]` - Create Product Requirements Documents
- `/implement [slug]` - Implement features from PRDs
- `/test [slug]` - Create comprehensive test suites
- `/review [slug]` - Quality gates and documentation
- Specialized subagents: `prd`, `expert`, `testing`, `docs-vision`, `sync-guides`

The agent system guides features through planning, implementation, testing, and review, ensuring all quality gates are met.

## 5. Release Workflow

### Standard Release

For regular releases (patch, minor, major):

```bash
# Ensure clean working tree
git status

# Bump version (choose one)
make release bump=patch   # 0.16.0 → 0.16.1
make release bump=minor   # 0.16.0 → 0.17.0
make release bump=major   # 0.16.0 → 1.0.0

# Push to main
git push origin main

# Create GitHub release
gh release create v0.16.0 --title "v0.16.0" --generate-notes
```

### Pre-releases (Alpha/Beta/RC)

For testing breaking changes with a limited audience before stable release:

```bash
# Start alpha
make pre-release version=0.16.0-alpha.1

# Iterate on alpha
make pre-release version=0.16.0-alpha.2

# Progress to beta
make pre-release version=0.16.0-beta.1

# Release candidate
make pre-release version=0.16.0-rc.1

# Push and create pre-release
git push origin HEAD
gh release create v0.16.0-alpha.1 --prerelease --title "v0.16.0-alpha.1"
```

**Distribution:**

- PyPI: Pre-release versions are automatically marked (users need `pip install --pre` or explicit version)
- npm: Published with `next` tag (users install via `npm install litestar-vite-plugin@next`)

**Finalizing:** When ready for stable, run `make release bump=minor` (or `patch` from RC).

---

# 3. Configuration Precedence

**Version**: 0.16.0 | **Updated**: 2026-01-04

```
┌─────────────────────┐
│   Python ViteConfig │
│   (VitePlugin)      │
└─────────┬───────────┘
          │ on_app_init()
          ▼
┌─────────────────────┐
│   .litestar.json    │
│   (Bridge File)     │
└─────────┬───────────┘
          │ loadPythonDefaults()
          ▼
┌─────────────────────┐    ┌─────────────────────┐
│   vite.config.ts    │───▶│  Resolved Config    │
│   (User TS Config)  │    │  + Validation       │
└─────────────────────┘    └─────────────────────┘
```

## Precedence Chain

**`vite.config.ts` > `.litestar.json` > hardcoded defaults**

1. **vite.config.ts** - Explicit user configuration takes highest priority
2. **.litestar.json** - Python-generated bridge file provides defaults
3. **Hardcoded defaults** - Built-in fallbacks when neither is available

## The Bridge File (`.litestar.json`)

When Litestar starts, it writes a `.litestar.json` file containing shared configuration:

```json
{
  "assetUrl": "/static/",
  "deployAssetUrl": null,
  "bundleDir": "public",
  "resourceDir": "src",
  "staticDir": "src/public",
  "hotFile": "hot",
  "manifest": "manifest.json",
  "mode": "spa",
  "proxyMode": "vite",
  "port": 5173,
  "host": "127.0.0.1",
  "ssrOutDir": null,
  "types": {
    "enabled": true,
    "output": "src/generated",
    "openapiPath": "src/generated/openapi.json",
    "routesPath": "src/generated/routes.json",
    "routesTsPath": "src/generated/routes.ts",
    "pagePropsPath": "src/generated/inertia-pages.json",
    "schemasTsPath": "src/generated/schemas.ts",
    "generateZod": false,
    "generateSdk": true,
    "generateRoutes": true,
    "generatePageProps": true,
    "generateSchemas": true,
    "globalRoute": false
  },
  "executor": "node",
  "logging": {
    "level": "normal",
    "showPathsAbsolute": false,
    "suppressNpmOutput": false,
    "suppressViteBanner": false,
    "timestamps": false
  },
  "litestarVersion": "2.15.0"
}
```

## Field Classification

### Shared Fields (in `.litestar.json`)

These fields are meaningful to both Python and TypeScript:

| Field | Python Name | JSON/TypeScript Name | Description |
|-------|-------------|---------------------|-------------|
| Asset URL | `asset_url` | `assetUrl` | Base URL for assets |
| Deploy Asset URL | `deploy.asset_url` | `deployAssetUrl` | Asset URL used during `vite build` |
| Bundle Directory | `bundle_dir` | `bundleDir` | Build output directory |
| Resource Directory | `resource_dir` | `resourceDir` | Source assets directory |
| Static Directory | `static_dir` | `staticDir` | Static assets directory |
| Hot File | `hot_file` | `hotFile` | Dev server URL file |
| Manifest Name | `manifest_name` | `manifest` | Build manifest filename |
| Mode | `mode` | `mode` | Operation mode |
| Proxy Mode | `proxy_mode` | `proxyMode` | Dev proxy configuration |
| Host | `host` | `host` | Dev server host |
| Port | `port` | `port` | Dev server port |
| SSR Output Dir | `ssr_output_dir` | `ssrOutDir` | SSR build output |
| Executor | `runtime.executor` | `executor` | Package manager command |
| Logging | `logging` | `logging` | Logging configuration |

### Python-Only Fields

These are configured in Python and not exposed to TypeScript:

- `DeployConfig` - CDN deployment settings (storage_backend, delete_orphaned, include_manifest, content_types)
- `SPAConfig` - Single-page app settings (inject_csrf, cache_transformed_html, csrf_var_name, app_selector)
- `InertiaConfig` - Inertia.js integration settings (root_template, component_opt_keys, encrypt_history, type_gen, use_script_element, precognition)
- `InertiaTypeGenConfig` - Inertia type generation (include_default_auth, include_default_flash)
- `InertiaSSRConfig` - Inertia SSR settings (enabled, url, timeout)
- `RuntimeConfig.run_command`, `build_command`, `serve_command`, `install_command`, etc.
- `RuntimeConfig.http2`, `start_dev_server`, `health_check`, `detect_nodeenv`, `set_environment`, `set_static_folders`, `csp_nonce`, `spa_handler`, `trusted_proxies`
- `ExternalDevServer` - External dev server config (target, command, build_command, http2, enabled)
- `PaginationContainer` - Protocol for pagination unwrapping
- `ViteConfig` fields: `guards`, `exclude_static_from_auth`, `spa_path`, `include_root_spa_paths`

### TypeScript-Only Fields

These are configured in `vite.config.ts` only:

- `input` - Entry point files
- `refresh` - HMR file patterns
- `detectTls` - Auto-detect HTTPS
- `autoDetectIndex` - Find index.html
- `transformOnServe` - HTML transforms in dev
- `types.debounce` - File watch debounce
- Vite-specific plugins, aliases, etc.

## Naming Convention

- **JSON/TypeScript**: `camelCase` (JavaScript convention)
- **Python**: `snake_case` (Python convention)

The bridge file uses camelCase since it's primarily consumed by JavaScript.

## Configuration Validation

The TypeScript plugin validates configuration against Python defaults and warns on mismatches:

```
[litestar-vite] Configuration mismatch detected:
  • bundleDir: vite.config.ts="dist" differs from Python="public"

Precedence: vite.config.ts > .litestar.json > defaults
See: https://docs.litestar.dev/vite/config-precedence
```

This helps catch configuration drift between Python and TypeScript.

## Best Practices

### 1. Let Python Drive Shared Config

Configure shared settings in Python's `ViteConfig`:

```python
# app.py
vite = VitePlugin(
    config=ViteConfig(
        paths=PathConfig(
            bundle_dir=Path("public/static"),
            resource_dir=Path("resources"),
        ),
        asset_url="/static/",
    )
)
```

### 2. Keep vite.config.ts Minimal

Only specify TypeScript-specific options:

```typescript
// vite.config.ts
export default defineConfig({
  plugins: [
    litestar({
      input: ["src/main.ts"],  // Required: entry points
      // Let Python defaults handle the rest
    }),
  ],
})
```

### 3. Override Only When Necessary

If you need to override Python defaults in TypeScript:

```typescript
// vite.config.ts
export default defineConfig({
  plugins: [
    litestar({
      input: ["src/main.ts"],
      bundleDir: "dist",  // Override Python default
      // Warning will be shown if this differs from .litestar.json
    }),
  ],
})
```

### 4. Run Litestar First in Development

The bridge file is created when Litestar starts:

```bash
# Start Litestar (creates .litestar.json)
litestar run

# Or use the integrated command
litestar assets serve
```

## Standalone JavaScript Mode

For projects not using Litestar's Python backend, configure everything in TypeScript:

```typescript
// vite.config.ts
export default defineConfig({
  plugins: [
    litestar({
      input: ["src/main.ts"],
      assetUrl: "/static/",
      bundleDir: "dist",
      resourceDir: "src",
      types: false,  // Disable type generation without Python
    }),
  ],
})
```

## Troubleshooting

### Missing .litestar.json Warning

If you see a warning about missing `.litestar.json`:

1. Start the Litestar backend first: `litestar run`
2. Or configure all options explicitly in `vite.config.ts`

### Configuration Mismatch Warning

If you see configuration mismatch warnings:

1. Review your `vite.config.ts` overrides
2. Either remove the override to use Python defaults
3. Or update Python config to match your TypeScript settings

### Debugging Configuration

Run the doctor command to diagnose issues:

```bash
litestar assets doctor
```

This shows a side-by-side comparison of Python and TypeScript configuration.

---

# 4. Testing Guide

**Version**: 0.16.0 | **Updated**: 2026-01-04

This guide provides instructions and best practices for writing and running tests in the `litestar-vite` project.

## Overview

The project uses a dual testing strategy for its Python backend and TypeScript frontend.

- **Backend (Python)**: [pytest](https://docs.pytest.org/) is the primary framework for all Python tests.
- **Frontend (TypeScript)**: [Vitest](https://vitest.dev/) is used for tests related to the core JavaScript/TypeScript library.

The full test suite can be run with a single command: `make test`.

## Backend Testing (pytest)

Python tests are located in `src/py/tests/`.

### Test Types

1. **Unit Tests (`src/py/tests/unit/`)**: These tests focus on individual components (functions, classes) in isolation. Dependencies, especially I/O-bound ones like databases or network calls, must be mocked.
    - **Framework**: `pytest`
    - **Mocks**: `unittest.mock` (especially `AsyncMock` for async code).

2. **Integration Tests (`src/py/tests/integration/`)**: These tests verify the interaction between multiple components. They may use real dependencies like a test database or a live Vite dev server process.

### Key Practices

- **Function-Based Tests**: All tests **must** be function-based. Do not use class-based tests (`class Test...:`).
    - Good: `async def test_inertia_response_flattens_props() -> None:`
    - Bad: `class TestInertiaResponse:`
- **Fixtures**: Use `pytest` fixtures (`@pytest.fixture`) to provide reusable setup and teardown logic, such as creating mock objects or database sessions.
- **Async Tests**: Mark `async` test functions with `@pytest.mark.asyncio`.
- **Coverage**: Aim for at least 90% test coverage for any new or modified code. The full coverage report can be generated with `make coverage`.

### Test Organization

Tests mirror the source structure:

```
src/py/tests/
├── unit/              # Fast, isolated tests
│   ├── inertia/       # Inertia-specific unit tests
│   ├── test_config.py
│   └── test_asset_loader.py
├── integration/       # Tests with real dependencies
│   ├── cli/           # CLI command integration tests
│   └── test_examples.py
└── conftest.py        # Shared fixtures
```

### Recent Test Patterns

The inertia-props-top-level feature introduced these test patterns:

1. **Props flattening tests**: Verify dict props are merged at top-level
2. **Content wrapping tests**: Verify non-dict content goes under `content` key
3. **Inertia protocol tests**: Test v2 protocol features (deferred, merge, prepend props)

### Running Python Tests

```bash
# Run all python tests
pytest src/py/tests/

# Run tests in parallel for speed
pytest -n auto src/py/tests/

# Run a specific test file
pytest src/py/tests/unit/test_config.py

# Run tests with coverage for a specific module
pytest --cov=src/py/litestar_vite/config src/py/tests/unit/test_config.py
```

## Frontend Testing (Vitest)

The core TypeScript library tests are located in `src/js/tests/`.

### Key Practices

- **Modern Syntax**: Use modern ES module syntax (`import`, `export`).
- **Mocking**: Use Vitest's built-in mocking capabilities (`vi.mock`, `vi.fn`).

### Running Frontend Tests

The frontend tests are typically run as part of the `make test` command. To run them in isolation:

```bash
# Run the tests
npm run test
```

## Full Suite

To ensure the entire project is working correctly, always run the full test and quality suite before submitting changes.

```bash
# Run all tests (Python + JS)
make test

# Run all linting, type-checking, and tests
make check-all

# Run with coverage report
make coverage

# Run only linting (includes pre-commit, type-check, slotscheck)
make lint

# Run only type checking (mypy + pyright)
make type-check
```

## Type Checking

The project uses multiple type checkers for comprehensive type safety:

```bash
# Run mypy (with cache)
make mypy

# Run mypy without cache
make mypy-nocache

# Run pyright
make pyright

# Run basedpyright (stricter variant)
make basedpyright

# Run all type checkers
make type-check
```

## Example Testing

Test all example applications to ensure integrations work correctly:

```bash
# Install dependencies for all examples
make install-examples

# Build all examples
make build-examples

# Run example integration tests
make test-examples
```

## End-to-End (E2E) Testing

E2E tests validate the complete developer experience by running actual servers.

### Critical: Use Litestar CLI Commands

**ALWAYS use `litestar assets` commands instead of npm/node directly in tests!**

```python
# CORRECT - Uses Litestar CLI
def start_dev_mode():
    # Start Vite dev server via Litestar
    subprocess.Popen(["litestar", "assets", "serve"], cwd=example_dir, env=env)
    # Start Litestar backend
    subprocess.Popen(["litestar", "run", "--port", str(port)], cwd=example_dir, env=env)

def start_production_mode():
    # Build assets via Litestar
    subprocess.run(["litestar", "assets", "build"], cwd=example_dir, env=env, check=True)
    # Start Litestar backend (serves static files)
    subprocess.Popen(["litestar", "run", "--port", str(port)], cwd=example_dir, env=env)
    # For SSR: also start production Node server
    subprocess.Popen(["litestar", "assets", "serve", "--production"], cwd=example_dir, env=env)

# WRONG - Bypasses Litestar integration
def start_dev_mode_wrong():
    subprocess.Popen(["npm", "run", "dev"])  # NO! Use litestar assets serve
    subprocess.Popen(["npm", "run", "build"])  # NO! Use litestar assets build
```

**Why this matters:**
- The Litestar CLI manages port allocation, environment variables, and process coordination
- Direct npm commands bypass the Python-JS integration layer
- Tests must validate the real developer experience, not just that npm works

### E2E Test Structure

```
src/py/tests/e2e/
├── __init__.py
├── conftest.py           # Server fixtures with caching and process cleanup
├── server_manager.py     # ExampleServer class using litestar CLI and port management
├── health_check.py       # HTTP polling utilities
├── assertions.py         # HTML/API validation helpers
├── test_dev_mode.py      # Dev mode tests for all examples
└── test_production_mode.py  # Production mode tests
```

### Running E2E Tests

```bash
# Run all E2E tests
make test-examples-e2e

# Run E2E tests for specific example
uv run pytest src/py/tests/e2e/ -k "react" -v

# Run with verbose output for debugging
uv run pytest src/py/tests/e2e/ -v -s
```

---

# 5. Code Style Guide

**Version**: 0.16.0 | **Updated**: 2026-01-04

This document defines the code style and quality standards for both the Python backend and TypeScript frontend. Consistency is enforced through automated tooling.

## General Principles

- **Clarity**: Write code that is easy to read and understand.
- **Explicitness**: Prefer explicit over implicit.
- **Consistency**: Adhere to the existing code style in the project.

## Python Code Style

All Python code is automatically formatted and linted using tools configured in `pyproject.toml` and run via `pre-commit` hooks.

- **Formatter**: [Ruff](https://docs.astral.sh/ruff/) is used for formatting, effectively replacing Black and isort.
- **Linter**: [Ruff](https://docs.astral.sh/ruff/) is also used for linting, providing fast and comprehensive checks.
- **Type Checking**: [MyPy](http://mypy-lang.org/) is used for static type checking.

### Key Standards

1. **Type Hinting**:
    - All functions and methods must have type hints for arguments and return values.
    - Use modern type hints (PEP 604): `list[str]` instead of `List[str]`, and `str | None` instead of `Optional[str]`.
    - Do **not** use `from __future__ import annotations`.

2. **Docstrings**:
    - All public modules, classes, functions, and methods must have a docstring.
    - Follow the [Google Python Style Guide](https://google.github.io/styleguide/pyguide.html#3.8-comments-and-docstrings) for docstrings.

3. **Imports**:
    - Imports are automatically sorted by Ruff.
    - Group imports logically (standard library, third-party, first-party).

### Additional Python Tools

- **Slotscheck**: Validates `__slots__` definitions for memory efficiency
- **Pre-commit**: Automated hooks for code quality (configured in `.pre-commit-config.yaml`)

### Tooling Commands

- **Lint & Type-Check**: `make lint` (runs pre-commit, mypy, pyright, slotscheck)
- **Auto-format**: `make fix` (runs ruff with auto-fixes)
- **Type-check only**: `make type-check` (runs mypy + pyright)
- **Slotscheck**: `make slotscheck` (validates `__slots__`)
- **Individual type checkers**:
    - `make mypy` - MyPy with cache
    - `make pyright` - Pyright
    - `make basedpyright` - Stricter Pyright variant

### Config Source of Truth

- When both Python and Vite need the same values (asset/base URL, bundle/resource dirs, manifest), prefer setting them in `ViteConfig`. The plugin's `on_app_init()` method writes `.litestar.json` during startup and the JS plugin uses it as defaults. Keep `vite.config.ts` overrides minimal.
- See `specs/guides/config-precedence.md` for detailed configuration flow documentation.

## TypeScript/JavaScript Code Style

The frontend codebase (primarily in `src/js/` and `examples/`) is managed by [Biome](https://biomejs.dev/).

- **Formatter**: Biome handles all code formatting.
- **Linter**: Biome provides comprehensive linting rules.

Configuration is defined in `biome.json`.

### Key Standards

1. **Formatting**:
    - Follow the settings in `biome.json` (e.g., indentation, line width).
    - Do not manually format code; let the tooling handle it.

2. **Language Features**:
    - Prefer modern ECMAScript features (e.g., `const`/`let` over `var`, arrow functions).
    - Use TypeScript for all new code to ensure type safety.

### Tooling Commands

The pre-commit hooks automatically run Biome. To run it manually:

```bash
# Format and lint all relevant files
npx biome check --write .
```

## Pre-Commit Hooks

This project uses `pre-commit` to ensure that all code committed to the repository meets our quality standards. The hooks are defined in `.pre-commit-config.yaml` and are installed automatically when you run `make install`.

The hooks will automatically run `ruff`, `biome`, `mypy`, and other checks before allowing a commit to be created.

---

# 6. API Reference

## Python API (`litestar_vite`)

### `VitePlugin`
The main entry point for integrating Vite with Litestar.

```python
class VitePlugin(InitPluginProtocol, CLIPlugin):
    def __init__(
        self,
        config: "ViteConfig | None" = None,
        asset_loader: "ViteAssetLoader | None" = None,
        static_files_config: "StaticFilesConfig | None" = None,
    ) -> None: ...
```

### `ViteConfig`
Root configuration class.

```python
@dataclass
class ViteConfig:
    mode: "Literal['spa', 'template', 'htmx', 'hybrid', 'inertia', 'framework', 'ssr', 'ssg', 'external'] | None" = None
    paths: PathConfig = field(default_factory=PathConfig)
    runtime: RuntimeConfig = field(default_factory=RuntimeConfig)
    types: "TypeGenConfig | bool | None" = None
    inertia: "InertiaConfig | bool | None" = None
    spa: "SPAConfig | bool | None" = None
    logging: "LoggingConfig | bool | None" = None
    dev_mode: bool = False
    base_url: "str | None" = None
    deploy: "DeployConfig | bool" = False
    guards: "Sequence[Guard] | None" = None
    exclude_static_from_auth: bool = True
    spa_path: "str | None" = None
    include_root_spa_paths: bool = False
```

### `InertiaPlugin`
Plugin for Inertia.js support.

```python
class InertiaPlugin(InitPluginProtocol):
    def __init__(self, config: "InertiaConfig") -> "None": ...
```

### `InertiaResponse`
Response class for Inertia requests, handling props flattening and content wrapping.

```python
class InertiaResponse(Response[T]):
    def __init__(
        self,
        content: T,
        status_code: int = 200,
        component: str | None = None,
        props: dict[str, Any] | None = None,
        # ... other Response args
    ) -> None: ...
```

## TypeScript API (`litestar-vite-plugin`)

### `litestar(config: PluginConfig)`
Vite plugin function.

```typescript
export default function litestar(config: string | string[] | PluginConfig): any[]
```

**`PluginConfig` Interface**:
- `input`: Entry points (string | string[]).
- `assetUrl`: Base asset URL (default: '/static/').
- `bundleDir`: Output dir (default: 'public/dist').
- `resourceDir`: Source dir (default: 'src').
- `hotFile`: Path to hot file.
- `ssr`: SSR entry point.
- `ssrOutDir`: SSR output dir.
- `refresh`: Full page reload config.
- `detectTls`: Auto-detect HTTPS.
- `autoDetectIndex`: Auto-detect index.html.
- `inertiaMode`: Disable index auto-detection for Inertia.
- `types`: Type generation config (boolean | "auto" | TypesConfig).
- `executor`: JS runtime ('node', 'bun', etc.).
